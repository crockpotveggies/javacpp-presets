// Targeted by JavaCPP version 1.2.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class dlib extends org.bytedeco.javacpp.presets.dlib {
    static { Loader.load(); }

// Parsed from <any.h>

// Copyright (C) 2010  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_AnY_
// #define DLIB_AnY_

// #include "any/any.h"
// #include "any/any_trainer.h"
// #include "any/any_decision_function.h"
// #include "any/any_function.h"

// #endif // DLIB_AnY_




// Parsed from <array.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_ARRAy_
// #define DLIB_ARRAy_

// #include "array/array_kernel.h"
// #include "array/array_tools.h"

// #endif // DLIB_ARRAy_



// Parsed from <array2d.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_ARRAY2d_ 
// #define DLIB_ARRAY2d_


// #include "array2d/array2d_kernel.h"
// #include "array2d/serialize_pixel_overloads.h"
// #include "array2d/array2d_generic_image.h"

// #endif // DLIB_ARRAY2d_



// Parsed from <assert.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_ASSERt_
// #define DLIB_ASSERt_

// #include "config.h"
// #include <sstream>
// #include <iosfwd>
// #include "error.h"

// -----------------------------

// Use some stuff from boost here
//  (C) Copyright John Maddock 2001 - 2003.
//  (C) Copyright Darin Adler 2001.
//  (C) Copyright Peter Dimov 2001.
//  (C) Copyright Bill Kempf 2002.
//  (C) Copyright Jens Maurer 2002.
//  (C) Copyright David Abrahams 2002 - 2003.
//  (C) Copyright Gennaro Prota 2003.
//  (C) Copyright Eric Friedman 2003.
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef BOOST_JOIN
// #define BOOST_JOIN( X, Y ) BOOST_DO_JOIN( X, Y )
// #define BOOST_DO_JOIN( X, Y ) BOOST_DO_JOIN2(X,Y)
// #define BOOST_DO_JOIN2( X, Y ) X##Y
// #endif

// figure out if the compiler has rvalue references. 
// #if defined(__clang__) 
// #   if __has_feature(cxx_rvalue_references)
// #       define DLIB_HAS_RVALUE_REFERENCES
// #   endif
// #   if __has_feature(cxx_generalized_initializers)
// #       define DLIB_HAS_INITIALIZER_LISTS
// #   endif
// #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 2)) && defined(__GXX_EXPERIMENTAL_CXX0X__) 
// #   define DLIB_HAS_RVALUE_REFERENCES
// #   define DLIB_HAS_INITIALIZER_LISTS
// #elif defined(_MSC_VER) && _MSC_VER >= 1600
// #   define DLIB_HAS_RVALUE_REFERENCES
// #elif defined(_MSC_VER) && _MSC_VER >= 1800
// #   define DLIB_HAS_INITIALIZER_LISTS
// #   define DLIB_HAS_RVALUE_REFERENCES
// #elif defined(__INTEL_COMPILER) && defined(BOOST_INTEL_STDCXX0X)
// #   define DLIB_HAS_RVALUE_REFERENCES
// #   define DLIB_HAS_INITIALIZER_LISTS
// #endif


// figure out if the compiler has static_assert. 
// #if defined(__clang__) 
// #   if __has_feature(cxx_static_assert)
// #       define DLIB_HAS_STATIC_ASSERT
// #   endif
// #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 2)) && defined(__GXX_EXPERIMENTAL_CXX0X__) 
// #   define DLIB_HAS_STATIC_ASSERT
// #elif defined(_MSC_VER) && _MSC_VER >= 1600
// #   define DLIB_HAS_STATIC_ASSERT
// #elif defined(__INTEL_COMPILER) && defined(BOOST_INTEL_STDCXX0X)
// #   define DLIB_HAS_STATIC_ASSERT
// #endif


// -----------------------------
    @Name("dlib::compile_time_assert<true>") public static class compile_time_assert extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public compile_time_assert() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public compile_time_assert(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public compile_time_assert(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public compile_time_assert position(long position) {
            return (compile_time_assert)super.position(position);
        }
     /** enum dlib::compile_time_assert<true>:: */
 public static final int value= 1;  }



// gcc 4.8 will warn about unused typedefs.  But we use typedefs in some of the compile
// time assert macros so we need to make it not complain about them "not being used".
// #ifdef __GNUC__
public static native @MemberGetter int DLIB_NO_WARN_UNUSED();
public static final int DLIB_NO_WARN_UNUSED = DLIB_NO_WARN_UNUSED();
// #else
// #define DLIB_NO_WARN_UNUSED 
// #endif

// Use the newer static_assert if it's available since it produces much more readable error
// messages.
// #ifdef DLIB_HAS_STATIC_ASSERT
// #else
//     #define COMPILE_TIME_ASSERT(expression)
//         DLIB_NO_WARN_UNUSED typedef char BOOST_JOIN(DLIB_CTA, __LINE__)[::dlib::compile_time_assert<(bool)(expression)>::value] 

//     #define ASSERT_ARE_SAME_TYPE(type1, type2)
//         DLIB_NO_WARN_UNUSED typedef char BOOST_JOIN(DLIB_AAST, __LINE__)[::dlib::assert_are_same_type<type1,type2>::value] 

//     #define ASSERT_ARE_NOT_SAME_TYPE(type1, type2)
//         DLIB_NO_WARN_UNUSED typedef char BOOST_JOIN(DLIB_AANST, __LINE__)[::dlib::assert_are_not_same_type<type1,type2>::value] 
// #endif

// -----------------------------

// #if defined DLIB_DISABLE_ASSERTS
    // if DLIB_DISABLE_ASSERTS is on then never enable DLIB_ASSERT no matter what.
//     #undef ENABLE_ASSERTS
// #endif

// #if !defined(DLIB_DISABLE_ASSERTS) && ( defined DEBUG || defined _DEBUG)
    // make sure ENABLE_ASSERTS is defined if we are indeed using them.
//     #ifndef ENABLE_ASSERTS
//         #define ENABLE_ASSERTS
//     #endif
// #endif

// -----------------------------

// #ifdef __GNUC__
// There is a bug in version 4.4.5 of GCC on Ubuntu which causes GCC to segfault
// when __PRETTY_FUNCTION__ is used within certain templated functions.  So just
// don't use it with this version of GCC.
// #  if !(__GNUC__ == 4 && __GNUC_MINOR__ == 4 && __GNUC_PATCHLEVEL__ == 5)
public static final int DLIB_FUNCTION_NAME = __PRETTY_FUNCTION__;
// #  else 
// #  endif
// #elif defined(_MSC_VER)
// #else 
// #endif

// #define DLIB_CASSERT(_exp,_message)
//     {if ( !(_exp) )
//     {
//         dlib_assert_breakpoint();
//         std::ostringstream dlib_o_out;
//         dlib_o_out << "\n\nError detected at line " << __LINE__ << ".\n";
//         dlib_o_out << "Error detected in file " << __FILE__ << ".\n";
//         dlib_o_out << "Error detected in function " << DLIB_FUNCTION_NAME << ".\n\n";
//         dlib_o_out << "Failing expression was " << #_exp << ".\n";
//         dlib_o_out << std::boolalpha << _message << "\n";
//         throw dlib::fatal_error(dlib::EBROKEN_ASSERT,dlib_o_out.str());
//     }}                                                                      


// #ifdef ENABLE_ASSERTS
// #else
//     #define DLIB_ASSERT(_exp,_message) {}
//     #define DLIB_IF_ASSERT(exp) 
// #endif

// ----------------------------------------------------------------------------------------

    /**A DLIB_ASSERT_HAS_STANDARD_LAYOUT 
    
        This macro is meant to cause a compiler error if a type doesn't have a simple
        memory layout (like a C struct). In particular, types with simple layouts are
        ones which can be copied via memcpy().
        
        
        This was called a POD type in C++03 and in C++0x we are looking to check if 
        it is a "standard layout type".  Once we can use C++0x we can change this macro 
        to something that uses the std::is_standard_layout type_traits class.  
        See: http://www2.research.att.com/~bs/C++0xFAQ.html#PODs
    !*/
    // Use the fact that in C++03 you can't put non-PODs into a union.
// #define DLIB_ASSERT_HAS_STANDARD_LAYOUT(type)
//     union  BOOST_JOIN(DAHSL_,__LINE__) { type TYPE_NOT_STANDARD_LAYOUT; };
//     DLIB_NO_WARN_UNUSED typedef char BOOST_JOIN(DAHSL2_,__LINE__)[sizeof(BOOST_JOIN(DAHSL_,__LINE__))]; 

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

// breakpoints
    public static native void dlib_assert_breakpoint(
        );
    /**
        ensures
            - this function does nothing 
              It exists just so you can put breakpoints on it in a debugging tool.
              It is called only when an DLIB_ASSERT or DLIB_CASSERT fails and is about to
              throw an exception.
    !*/

// -----------------------------

// #include "stack_trace.h"

// #endif // DLIB_ASSERt_



// Parsed from <base64.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BASe64_
// #define DLIB_BASe64_

// #include "base64/base64_kernel_1.h"

// #endif // DLIB_BASe64_



// Parsed from <bayes_utils.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BAYES_UTILs_H_
// #define DLIB_BAYES_UTILs_H_ 

// #include "bayes_utils/bayes_utils.h"

// #endif // DLIB_BAYES_UTILs_H_ 





// Parsed from <bigint.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BIGINt_
// #define DLIB_BIGINt_

// #include "bigint/bigint_kernel_1.h"
// #include "bigint/bigint_kernel_2.h"
// #include "bigint/bigint_kernel_c.h"


    @Namespace("dlib") public static class bigint extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public bigint(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        
          
        // kernel_2a        
          

    }


// #endif // DLIB_BIGINt_



// Parsed from <binary_search_tree.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BINARY_SEARCH_TREe_
// #define DLIB_BINARY_SEARCH_TREe_


// #include "binary_search_tree/binary_search_tree_kernel_1.h"
// #include "binary_search_tree/binary_search_tree_kernel_2.h"
// #include "binary_search_tree/binary_search_tree_kernel_c.h"


// #include "algs.h"
// #include <functional>


// #endif // DLIB_BINARY_SEARCH_TREe_



// Parsed from <bit_stream.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BIT_STREAm_
// #define DLIB_BIT_STREAm_

// #include "bit_stream/bit_stream_kernel_1.h"
// #include "bit_stream/bit_stream_kernel_c.h"

// #include "bit_stream/bit_stream_multi_1.h"
// #include "bit_stream/bit_stream_multi_c.h"


    @Namespace("dlib") public static class bit_stream extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public bit_stream(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        

        //---------- extensions ------------

        
        // multi_1 extend kernel_1a

    }


// #endif // DLIB_BIT_STREAm_



// Parsed from <bound_function_pointer.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BOUND_FUNCTION_POINTEr_
// #define DLIB_BOUND_FUNCTION_POINTEr_

// #include "bound_function_pointer/bound_function_pointer_kernel_1.h"

// #endif // DLIB_BOUND_FUNCTION_POINTEr_ 




// Parsed from <bridge.h>

// Copyright (C) 2011  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif


// #ifndef DLIB_BRIdGE_
// #define DLIB_BRIdGE_ 


// #include "bridge/bridge.h"

// #endif // DLIB_BRIdGE_ 




// Parsed from <bsp.h>

// Copyright (C) 2012  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BSPh_
// #define DLIB_BSPh_ 


// #include "bsp/bsp.h"

// #endif // DLIB_BSPh_ 





// Parsed from <byte_orderer.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_BYTE_ORDEREr_ 
// #define DLIB_BYTE_ORDEREr_ 


// #include "byte_orderer/byte_orderer_kernel_1.h"

// #endif // DLIB_BYTE_ORDEREr_ 



// Parsed from <clustering.h>

// Copyright (C) 2012  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CLuSTERING_
// #define DLIB_CLuSTERING_

// #include "clustering/modularity_clustering.h"
// #include "clustering/chinese_whispers.h"
// #include "clustering/spectral_cluster.h"
// #include "clustering/bottom_up_cluster.h"
// #include "svm/kkmeans.h"

// #endif // DLIB_CLuSTERING_



// Parsed from <cmd_line_parser.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CMD_LINE_PARSEr_
// #define DLIB_CMD_LINE_PARSEr_

// #include "cmd_line_parser/cmd_line_parser_kernel_1.h"
// #include "cmd_line_parser/cmd_line_parser_kernel_c.h"
// #include "cmd_line_parser/cmd_line_parser_print_1.h"
// #include "cmd_line_parser/cmd_line_parser_check_1.h"
// #include "cmd_line_parser/cmd_line_parser_check_c.h"
// #include <string>
// #include "cmd_line_parser/get_option.h"

// #include "map.h"
// #include "sequence.h"

// ----------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------- 

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------



// #endif // DLIB_CMD_LINE_PARSEr_



// Parsed from <compress_stream.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_COMPRESS_STREAm_
// #define DLIB_COMPRESS_STREAm_

// #include "compress_stream/compress_stream_kernel_1.h"
// #include "compress_stream/compress_stream_kernel_2.h"
// #include "compress_stream/compress_stream_kernel_3.h"

// #include "conditioning_class.h"
// #include "entropy_encoder.h"
// #include "entropy_decoder.h"

// #include "entropy_encoder_model.h"
// #include "entropy_decoder_model.h"
// #include "lz77_buffer.h"
// #include "sliding_buffer.h"
// #include "lzp_buffer.h"
// #include "crc32.h"

    @Namespace("dlib") public static class compress_stream extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public compress_stream(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        
   
        // kernel_1b        

        // kernel_1c        

        // kernel_1da        

        // kernel_1ea        

        // kernel_1db        

        // kernel_1eb        

        // kernel_1ec        




        // kernel_2a        




        // kernel_3a        
        // kernel_3b        
   

    }


// #endif // DLIB_COMPRESS_STREAm_



// Parsed from <conditioning_class.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CONDITIONING_CLASs_
// #define DLIB_CONDITIONING_CLASs_

// #include "conditioning_class/conditioning_class_kernel_1.h"
// #include "conditioning_class/conditioning_class_kernel_2.h"
// #include "conditioning_class/conditioning_class_kernel_3.h"
// #include "conditioning_class/conditioning_class_kernel_4.h"
// #include "conditioning_class/conditioning_class_kernel_c.h"


// #include "memory_manager.h"


// #endif // DLIB_CONDITIONING_CLASS_



// Parsed from <config.h>



// If you are compiling dlib as a shared library and installing it somewhere on your system
// then it is important that any programs that use dlib agree on the state of the
// DLIB_ASSERT statements (i.e. they are either always on or always off).  Therefore,
// uncomment one of the following lines to force all DLIB_ASSERTs to either always on or
// always off.  If you don't define one of these two macros then DLIB_ASSERT will toggle
// automatically depending on the state of certain other macros, which is not what you want
// when creating a shared library.
/* #undef ENABLE_ASSERTS */
// #define DLIB_DISABLE_ASSERTS // asserts always disabled 

/* #undef DLIB_ISO_CPP_ONLY */
/* #undef DLIB_NO_GUI_SUPPORT */
/* #undef DLIB_ENABLE_STACK_TRACE */

// You should also consider telling dlib to link against libjpeg, libpng, libgif, fftw, CUDA, 
// and a BLAS and LAPACK library.  To do this you need to uncomment the following #defines.
// #define DLIB_JPEG_SUPPORT
// #define DLIB_PNG_SUPPORT
// #define DLIB_GIF_SUPPORT
/* #undef DLIB_USE_FFTW */
// #define DLIB_USE_BLAS
// #define DLIB_USE_LAPACK
/* #undef DLIB_USE_CUDA */


// Parsed from <config_reader.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CONFIG_READEr_
// #define DLIB_CONFIG_READEr_

// #include "config_reader/config_reader_kernel_1.h"
// #include "map.h"
// #include "tokenizer.h"
// #include "cmd_line_parser/get_option.h"

// #include "algs.h"
// #include "is_kind.h"

    @Name("is_config_reader<dlib::config_reader>") public static class is_config_reader<dlib::config_reader> extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public is_config_reader<dlib::config_reader>() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public is_config_reader<dlib::config_reader>(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public is_config_reader<dlib::config_reader>(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public is_config_reader<dlib::config_reader> position(long position) {
            return (is_config_reader<dlib::config_reader>)super.position(position);
        }
     @MemberGetter public static native @Cast("const bool") boolean value();
public static final boolean value = value(); }

// #ifndef DLIB_ISO_CPP_ONLY
// #endif // DLIB_ISO_CPP_ONLY




// #endif // DLIB_CONFIG_READEr_



// Parsed from <console_progress_indicator.h>

// Copyright (C) 2010  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CONSOLE_PROGRESS_INDiCATOR_Hh_
// #define DLIB_CONSOLE_PROGRESS_INDiCATOR_Hh_

// #include <ctime>
// #include <cmath>
// #include <limits>
// #include <iostream>

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") @NoOffset public static class console_progress_indicator extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public console_progress_indicator(Pointer p) { super(p); }
    

        public console_progress_indicator(
                    double target_value 
                ) { super((Pointer)null); allocate(target_value); }
        private native void allocate(
                    double target_value 
                ); 
        /**
            ensures
                - #target() == target_value
        !*/

        public native void reset(
                    double target_value
                );
        /**
            ensures
                - #target() == target_value
                - performs the equivalent of:
                    *this = console_progress_indicator(target_value)
                    (i.e. resets this object with a new target value)
        <p>
        !*/

        public native double target(
                );
        /**
            ensures
                - This object attempts to measure how much time is
                  left until we reach a certain targeted value.  This
                  function returns that targeted value.
        !*/

        public native @Cast("bool") boolean print_status(
                    double cur,
                    @Cast("bool") boolean always_print/*=false*/
                );
        public native @Cast("bool") boolean print_status(
                    double cur
                );

    }

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
//                               IMPLEMENTATION DETAILS
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

    

// ----------------------------------------------------------------------------------------

    

// ----------------------------------------------------------------------------------------

    

// ----------------------------------------------------------------------------------------

    

// ----------------------------------------------------------------------------------------



// #endif // DLIB_CONSOLE_PROGRESS_INDiCATOR_Hh_



// Parsed from <control.h>

// Copyright (C) 2015  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CONTRoL_
// #define DLIB_CONTRoL_

// #include "control/lspi.h"
// #include "control/mpc.h"

// #endif // DLIB_CONTRoL_




// Parsed from <cpp_pretty_printer.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CPP_PRETTY_PRINTEr_
// #define DLIB_CPP_PRETTY_PRINTEr_


// #include "cpp_pretty_printer/cpp_pretty_printer_kernel_1.h"
// #include "cpp_pretty_printer/cpp_pretty_printer_kernel_2.h"
// #include "cpp_tokenizer.h"
// #include "stack.h"

    @Namespace("dlib") public static class cpp_pretty_printer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public cpp_pretty_printer(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        

        // kernel_2a        

    }


// #endif // DLIB_CPP_PRETTY_PRINTEr_



// Parsed from <cpp_tokenizer.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CPP_TOKENIZEr_
// #define DLIB_CPP_TOKENIZEr_

// #include <string>
// #include "cpp_tokenizer/cpp_tokenizer_kernel_1.h"
// #include "cpp_tokenizer/cpp_tokenizer_kernel_c.h"
// #include "tokenizer.h"
// #include "queue.h"
// #include "set.h"

    @Namespace("dlib") public static class cpp_tokenizer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public cpp_tokenizer(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        
          

    }


// #endif // DLIB_CPP_TOKENIZEr_



// Parsed from <crc32.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_CRc32_
// #define DLIB_CRc32_


// #include "crc32/crc32_kernel_1.h"

// #endif // DLIB_CRc32_



// Parsed from <data_io.h>

// Copyright (C) 2010  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_DATA_Io_HEADER
// #define DLIB_DATA_Io_HEADER

// #include "data_io/libsvm_io.h"
// #include "data_io/image_dataset_metadata.h"
// #include "data_io/mnist.h"

// #ifndef DLIB_ISO_CPP_ONLY
// #include "data_io/load_image_dataset.h"
// #endif

// #endif // DLIB_DATA_Io_HEADER






// Parsed from <dir_nav.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_DIR_NAv_
// #define DLIB_DIR_NAv_


// #include "platform.h"


// #ifdef WIN32
// #include "dir_nav/windows.h"
// #endif

// #ifndef WIN32
// #include "dir_nav/posix.h"
// #endif

// #include "dir_nav/dir_nav_extensions.h"

// #endif // DLIB_DIR_NAv_



// Parsed from <directed_graph.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_DIRECTED_GRAPh_
// #define DLIB_DIRECTED_GRAPh_

// #include "directed_graph/directed_graph_kernel_1.h"

// #include "algs.h"


// #endif // DLIB_DIRECTED_GRAPh_ 




// Parsed from <disjoint_subsets.h>

// Copyright (C) 2011  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_DISJOINt_SUBSETS_
// #define DLIB_DISJOINt_SUBSETS_


// #include "disjoint_subsets/disjoint_subsets.h"

// #endif // DLIB_DISJOINt_SUBSETS_




// Parsed from <dnn.h>

// Copyright (C) 2015  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_DNn_
// #define DLIB_DNn_

// DNN module uses template-based network declaration that leads to very long
// type names. Visual Studio will produce Warning C4503 in such cases
// #ifdef _MSC_VER
// #   pragma warning( disable: 4503 )
// #endif

// #include "dnn/tensor.h"
// #include "dnn/input.h"
// #include "dnn/layers.h"
// #include "dnn/loss.h"
// #include "dnn/core.h"
// #include "dnn/solvers.h"
// #include "dnn/trainer.h"
// #include "dnn/cpu_dlib.h"
// #include "dnn/tensor_tools.h"
// #include "dnn/utilities.h"

// #endif // DLIB_DNn_




// Parsed from <enable_if.h>

// Copyright 2003 (C) The Trustees of Indiana University.
// Use, modification, and distribution is subject to the Boost Software
// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//    Authors: Jaakko Jarvi (jajarvi at osl.iu.edu)
//             Jeremiah Willcock (jewillco at osl.iu.edu)
//             Andrew Lumsdaine (lums at osl.iu.edu)
// #ifndef DLIB_BOOST_UTILITY_ENABLE_IF_HPP
// #define DLIB_BOOST_UTILITY_ENABLE_IF_HPP

 // namespace dlib 

// #endif // DLIB_BOOST_UTILITY_ENABLE_IF_HPP



// Parsed from <entropy_decoder.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_ENTROPY_DECODEr_
// #define DLIB_ENTROPY_DECODEr_

// #include "entropy_decoder/entropy_decoder_kernel_1.h"
// #include "entropy_decoder/entropy_decoder_kernel_2.h"
// #include "entropy_decoder/entropy_decoder_kernel_c.h"


    @Namespace("dlib") public static class entropy_decoder extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public entropy_decoder(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        
          

        // kernel_2a        
          

    }


// #endif // DLIB_ENTROPY_DECODEr_



// Parsed from <entropy_decoder_model.h>

// Copyright (C) 2004  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_ENTROPY_DECODER_MODEl_
// #define DLIB_ENTROPY_DECODER_MODEl_

// #include "entropy_decoder_model/entropy_decoder_model_kernel_1.h"
// #include "entropy_decoder_model/entropy_decoder_model_kernel_2.h"
// #include "entropy_decoder_model/entropy_decoder_model_kernel_3.h"
// #include "entropy_decoder_model/entropy_decoder_model_kernel_4.h"
// #include "entropy_decoder_model/entropy_decoder_model_kernel_5.h"
// #include "entropy_decoder_model/entropy_decoder_model_kernel_6.h"

// #include "conditioning_class.h"
// #include "memory_manager.h"


// #endif // DLIB_ENTROPY_DECODER_MODEl_



// Parsed from <entropy_encoder.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_ENTROPY_ENCODEr_
// #define DLIB_ENTROPY_ENCODEr_

// #include "entropy_encoder/entropy_encoder_kernel_1.h"
// #include "entropy_encoder/entropy_encoder_kernel_2.h"
// #include "entropy_encoder/entropy_encoder_kernel_c.h"


    @Namespace("dlib") public static class entropy_encoder extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public entropy_encoder(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        
          

        // kernel_2a        

    }


// #endif // DLIB_ENTROPY_ENCODEr_



// Parsed from <entropy_encoder_model.h>

// Copyright (C) 2004  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_ENTROPY_ENCODER_MODEl_
// #define DLIB_ENTROPY_ENCODER_MODEl_

// #include "entropy_encoder_model/entropy_encoder_model_kernel_1.h"
// #include "entropy_encoder_model/entropy_encoder_model_kernel_2.h"
// #include "entropy_encoder_model/entropy_encoder_model_kernel_3.h"
// #include "entropy_encoder_model/entropy_encoder_model_kernel_4.h"
// #include "entropy_encoder_model/entropy_encoder_model_kernel_5.h"
// #include "entropy_encoder_model/entropy_encoder_model_kernel_6.h"
// #include "entropy_encoder_model/entropy_encoder_model_kernel_c.h"

// #include "conditioning_class.h"
// #include "memory_manager.h"
// #include "sliding_buffer.h"


// #endif // DLIB_ENTROPY_ENCODER_MODEl_



// Parsed from <filtering.h>

// Copyright (C) 2012  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_FILTERiNG_HEADER
// #define DLIB_FILTERiNG_HEADER

// #include "filtering/kalman_filter.h"
// #include "filtering/rls_filter.h"

// #endif // DLIB_FILTERiNG_HEADER





// Parsed from <float_details.h>

// Copyright (C) 2013  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_FLOAT_DEtAILS_Hh_
// #define DLIB_FLOAT_DEtAILS_Hh_

// #include <cmath>
// #include "algs.h"
// #include <limits>
    @Namespace("dlib") @NoOffset public static class float_details extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public float_details(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public float_details(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public float_details position(long position) {
            return (float_details)super.position(position);
        }
    
        /**
            WHAT THIS OBJECT REPRESENTS
                This object is a tool for converting floating point numbers into an
                explicit integer representation and then also converting back.  In
                particular, a float_details object represents a floating point number with
                a 64 bit mantissa and 16 bit exponent.  These are stored in the public
                fields of the same names.
                <p>
                The main use of this object is to convert floating point values into a
                known uniform representation so they can be serialized to an output stream.
                This allows dlib serialization code to work on any system, regardless of
                the floating point representation used by the hardware.  It also means
                that, for example, a double can be serialized and then deserialized into a
                float and it will perform the appropriate conversion.
                <p>
                <p>
                In more detail, this object represents a floating point value equal to
                mantissa*pow(2,exponent), except when exponent takes on any of the
                following special values: 
                    - is_inf
                    - is_ninf
                    - is_nan
                These values are used to indicate that the floating point value should be
                either infinity, negative infinity, or not-a-number respectively.
        !*/

        public float_details(
                    @ByVal int64 man,
                    @ByVal int16 exp
                ) { super((Pointer)null); allocate(man, exp); }
        private native void allocate(
                    @ByVal int64 man,
                    @ByVal int16 exp
                );
        /**
            ensures
                - #mantissa == man
                - #exponent == exp
        !*/

        public float_details() { super((Pointer)null); allocate(); }
        private native void allocate();
        /**
            ensures
                - this object represents a floating point value of 0
        !*/

        public float_details( double val) { super((Pointer)null); allocate(val); }
        private native void allocate( double val);
        public float_details( float val) { super((Pointer)null); allocate(val); }
        private native void allocate( float val);
        /**
            ensures
                - converts the given value into a float_details representation.  This 
                  means that converting #*this back into a floating point number should
                  recover the input val.
        !*/

        public native @ByRef @Name("operator =") float_details put( double val);
        public native @ByRef @Name("operator =") float_details put( float val);
        /**
            ensures
                - converts the given value into a float_details representation.  This 
                  means that converting #*this back into a floating point number should
                  recover the input val.
        !*/

        public native @Name("operator double") double asDouble();
        public native @Name("operator float") float asFloat();
        /**
            ensures
                - converts the contents of this float_details object into a floating point number.
        !*/

        @MemberGetter public static native @Const @ByRef int16 is_inf();
        @MemberGetter public static native @Const @ByRef int16 is_ninf();
        @MemberGetter public static native @Const @ByRef int16 is_nan();

        public native @ByRef int64 mantissa(); public native float_details mantissa(int64 mantissa);
        public native @ByRef int16 exponent(); public native float_details exponent(int16 exponent);

    }



// #endif // DLIB_FLOAT_DEtAILS_Hh_



// Parsed from <geometry.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_GEOMETRy_HEADER
// #define DLIB_GEOMETRy_HEADER

// #include "geometry/rectangle.h"
// #include "geometry/drectangle.h"
// #include "geometry/vector.h"
// #include "geometry/border_enumerator.h"
// #include "geometry/point_transforms.h"

// #endif // DLIB_GEOMETRy_HEADER




// Parsed from <graph.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_GRAPh_
// #define DLIB_GRAPh_

// #include "graph/graph_kernel_1.h"

// #include "algs.h"


// #endif // DLIB_GRAPh_ 




// Parsed from <graph_cuts.h>

// Copyright (C) 2012  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_GRAPH_CUTs_HEADER_
// #define DLIB_GRAPH_CUTs_HEADER_

// #include "graph_cuts/min_cut.h"
// #include "graph_cuts/general_flow_graph.h"
// #include "graph_cuts/find_max_factor_graph_potts.h"
// #include "graph_cuts/graph_labeler.h"

// #endif // DLIB_GRAPH_CUTs_HEADER_





// Parsed from <graph_utils.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_GRAPH_UTILs_H_
// #define DLIB_GRAPH_UTILs_H_ 

// #include "graph_utils/graph_utils.h"
// #include "graph_utils/edge_list_graphs.h"
// #include "graph_utils/function_objects.h"

// #endif // DLIB_GRAPH_UTILs_H_ 




// Parsed from <graph_utils_threaded.h>

// Copyright (C) 2013  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_GRAPH_UTILs_THREADED_H_
// #define DLIB_GRAPH_UTILs_THREADED_H_ 

// #include "graph_utils.h"
// #include "graph_utils/find_k_nearest_neighbors_lsh.h"

// #endif // DLIB_GRAPH_UTILs_THREADED_H_ 





// Parsed from <gui_core.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_GUI_CORe_
// #define DLIB_GUI_CORe_


// #include "platform.h"



// #ifdef WIN32
// #include "gui_core/windows.h"
// #else
// #include "gui_core/xlib.h"
// #endif



// #endif // DLIB_GUI_CORe_



// Parsed from <gui_widgets.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_GUI_WIDGETs_
// #define DLIB_GUI_WIDGETs_



// #include "gui_widgets/widgets.h"



// #endif // DLIB_GUI_WIDGETs_



// Parsed from <hash.h>

// Copyright (C) 2011  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_HASh_
// #define DLIB_HASh_


// #include "general_hash/hash.h"
// #include "general_hash/random_hashing.h"
// #include "general_hash/count_bits.h"


// #endif // DLIB_HASh_




// Parsed from <hash_map.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_HASH_MAp_
// #define DLIB_HASH_MAp_

// #include "hash_map/hash_map_kernel_1.h"
// #include "hash_map/hash_map_kernel_c.h"

// #include "hash_table.h"
// #include "algs.h"

// #include "algs.h"
// #include <functional>


// #endif // DLIB_HASH_MAp_



// Parsed from <hash_set.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_HASH_SEt_
// #define DLIB_HASH_SEt_

// #include "hash_set/hash_set_kernel_1.h"
// #include "hash_set/hash_set_kernel_c.h"

// #include "hash_table.h"
// #include "algs.h"


// #include "algs.h"
// #include <functional>


// #endif // DLIB_HASH_SEt_



// Parsed from <hash_table.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_HASH_TABLe_
// #define DLIB_HASH_TABLe_


// #include "hash_table/hash_table_kernel_1.h"
// #include "hash_table/hash_table_kernel_2.h"
// #include "hash_table/hash_table_kernel_c.h"
// #include "algs.h"

// #include "binary_search_tree.h"
// #include <functional>


// #endif // DLIB_HASH_TABLe_



// Parsed from <image_io.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_IMAGe_IO_ 
// #define DLIB_IMAGe_IO_

// #include "image_loader/image_loader.h"
// #include "image_loader/png_loader.h"
// #include "image_loader/jpeg_loader.h"
// #include "image_loader/load_image.h"
// #include "image_saver/image_saver.h"
// #include "image_saver/save_png.h"
// #include "image_saver/save_jpeg.h"

// #endif // DLIB_IMAGe_IO_ 



// Parsed from <image_keypoint.h>

// Copyright (C) 2009  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_IMAGE_KEYPOINt_H_
// #define DLIB_IMAGE_KEYPOINt_H_ 

// #include "image_keypoint/surf.h"
// #include "image_keypoint/hessian_pyramid.h"
// #include "image_keypoint/hog.h"
// #include "image_keypoint/poly_image.h"
// #include "image_keypoint/fine_hog_image.h"
// #include "image_keypoint/hashed_feature_image.h"
// #include "image_keypoint/nearest_neighbor_feature_image.h"
// #include "image_keypoint/binned_vector_feature_image.h"

// #endif // DLIB_IMAGE_KEYPOINt_H_



// Parsed from <image_processing.h>

// Copyright (C) 2011  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_IMAGE_PROCESSInG_H_h_
// #define DLIB_IMAGE_PROCESSInG_H_h_ 

// #include "image_processing/scan_image.h"
// #include "image_processing/scan_image_pyramid.h"
// #include "image_processing/detection_template_tools.h"
// #include "image_processing/object_detector.h"
// #include "image_processing/box_overlap_testing.h"
// #include "image_processing/scan_image_pyramid_tools.h"
// #include "image_processing/setup_hashed_features.h"
// #include "image_processing/scan_image_boxes.h"
// #include "image_processing/scan_image_custom.h"
// #include "image_processing/remove_unobtainable_rectangles.h"
// #include "image_processing/scan_fhog_pyramid.h"
// #include "image_processing/shape_predictor.h"
// #include "image_processing/correlation_tracker.h"

// #endif // DLIB_IMAGE_PROCESSInG_H_h_




// Parsed from <image_transforms.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_IMAGE_TRANSFORMs_
// #define DLIB_IMAGE_TRANSFORMs_ 

// #include "image_transforms/assign_image.h"
// #include "image_transforms/equalize_histogram.h"
// #include "image_transforms/morphological_operations.h"
// #include "image_transforms/spatial_filtering.h"
// #include "image_transforms/thresholding.h"
// #include "image_transforms/edge_detector.h"
// #include "image_transforms/draw.h"
// #include "image_transforms/integral_image.h"
// #include "image_transforms/image_pyramid.h"
// #include "image_transforms/hough_transform.h"
// #include "image_transforms/label_connected_blobs.h"
// #include "image_transforms/colormaps.h"
// #include "image_transforms/segment_image.h"
// #include "image_transforms/interpolation.h"
// #include "image_transforms/fhog.h"
// #include "image_transforms/lbp.h"
// #include "image_transforms/random_color_transform.h"

// #endif // DLIB_IMAGE_TRANSFORMs_



// Parsed from <iosockstream.h>

// Copyright (C) 2012  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_IOSOCkSTREAM_H_h_
// #define DLIB_IOSOCkSTREAM_H_h_

// #include "iosockstream/iosockstream.h"


// #endif // DLIB_IOSOCkSTREAM_H_h_




// Parsed from <is_kind.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_IS_KINd_H_
// #define DLIB_IS_KINd_H_

// #include <vector>
    /**
        This file contains a set of templates that enable you to determine if
        a given type implements an abstract interface defined in one of the
        dlib *_abstract.h files.
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static class default_is_kind_value extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public default_is_kind_value() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public default_is_kind_value(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public default_is_kind_value(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public default_is_kind_value position(long position) {
            return (default_is_kind_value)super.position(position);
        }
     @MemberGetter public static native @Cast("const bool") boolean value();
public static final boolean value = value(); }

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
//                              Implementation details
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------



// #endif // DLIB_IS_KINd_H_



// Parsed from <linker.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_LINKEr_
// #define DLIB_LINKEr_

// #include "linker/linker_kernel_1.h"

// #endif // DLIB_LINKEr_



// Parsed from <logger.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_LOGGEr_
// #define DLIB_LOGGEr_

// #include "logger/logger_kernel_1.h"
// #include "logger/extra_logger_headers.h"
// #include "logger/logger_config_file.h"

// #endif // DLIB_LOGGEr_ 



// Parsed from <lsh.h>

// Copyright (C) 2011  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_LSh_
// #define DLIB_LSh_


// #include "lsh/projection_hash.h"
// #include "lsh/create_random_projection_hash.h"
// #include "lsh/hashes.h"


// #endif // DLIB_LSh_




// Parsed from <lz77_buffer.h>

// Copyright (C) 2004  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_LZ77_BUFFEr_
// #define DLIB_LZ77_BUFFEr_


// #include "lz77_buffer/lz77_buffer_kernel_1.h"
// #include "lz77_buffer/lz77_buffer_kernel_2.h"
// #include "lz77_buffer/lz77_buffer_kernel_c.h"

// #include "sliding_buffer.h"


    @Namespace("dlib") public static class lz77_buffer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public lz77_buffer(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        


        // kernel_2a        
   

    }


// #endif // DLIB_LZ77_BUFFEr_



// Parsed from <lzp_buffer.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_LZP_BUFFEr_
// #define DLIB_LZP_BUFFEr_


// #include "lzp_buffer/lzp_buffer_kernel_1.h"
// #include "lzp_buffer/lzp_buffer_kernel_2.h"
// #include "lzp_buffer/lzp_buffer_kernel_c.h"

// #include "sliding_buffer.h"


    @Namespace("dlib") public static class lzp_buffer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public lzp_buffer(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        

        // kernel_2a        
  

    }


// #endif // DLIB_LZP_BUFFEr_



// Parsed from <manifold_regularization.h>

// Copyright (C) 2010  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MANIFOLD_REGULARIzATION_HEADER
// #define DLIB_MANIFOLD_REGULARIzATION_HEADER

// #include "graph_utils/edge_list_graphs.h"
// #include "manifold_regularization/linear_manifold_regularizer.h"
// #include "graph_utils/function_objects.h"

// #endif // DLIB_MANIFOLD_REGULARIzATION_HEADER





// Parsed from <map.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MAp_
// #define DLIB_MAp_

// #include "map/map_kernel_1.h"
// #include "map/map_kernel_c.h"

// #include "binary_search_tree.h"


// #include "algs.h"
// #include <functional>


// #endif // DLIB_MAp_



// Parsed from <matrix.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MATRIx_HEADER
// #define DLIB_MATRIx_HEADER

// #include "matrix/matrix.h"
// #include "matrix/matrix_utilities.h"
// #include "matrix/matrix_subexp.h"
// #include "matrix/matrix_math_functions.h"
// #include "matrix/matrix_assign.h"
// #include "matrix/matrix_la.h"
// #include "matrix/symmetric_matrix_cache.h"
// #include "matrix/matrix_conv.h"
// #include "matrix/matrix_read_from_istream.h"
// #include "matrix/matrix_fft.h"
// #include "matrix/matrix_generic_image.h"

// #ifdef DLIB_USE_BLAS
// #endif

// #endif // DLIB_MATRIx_HEADER




// Parsed from <md5.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #include "md5/md5_kernel_1.h"


// Parsed from <member_function_pointer.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MEMBER_FUNCTION_POINTEr_
// #define DLIB_MEMBER_FUNCTION_POINTEr_

// #include "member_function_pointer/member_function_pointer_kernel_1.h"
// #include "member_function_pointer/make_mfp.h"

// #endif // DLIB_MEMBER_FUNCTION_POINTEr_ 



// Parsed from <memory_manager.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MEMORY_MANAGEr_
// #define DLIB_MEMORY_MANAGEr_

// #include "memory_manager/memory_manager_kernel_1.h"
// #include "memory_manager/memory_manager_kernel_2.h"
// #include "memory_manager/memory_manager_kernel_3.h"


// #endif // DLIB_MEMORY_MANAGEr_



// Parsed from <memory_manager_global.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MEMORY_MANAGER_GLOBAl_
// #define DLIB_MEMORY_MANAGER_GLOBAl_

// #include "memory_manager_global/memory_manager_global_kernel_1.h"
// #include "memory_manager.h"


// #endif // DLIB_MEMORY_MANAGER_GLOBAl_



// Parsed from <memory_manager_stateless.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MEMORY_MANAGER_STATELESs_
// #define DLIB_MEMORY_MANAGER_STATELESs_

// #include "memory_manager_stateless/memory_manager_stateless_kernel_1.h"
// #include "memory_manager_stateless/memory_manager_stateless_kernel_2.h"
// #include "memory_manager.h"


// #endif // DLIB_MEMORY_MANAGER_STATELESs_



// Parsed from <misc_api.h>

// Copyright (C) 2004  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifndef DLIB_MISC_APi_
// #define DLIB_MISC_APi_

// #include "platform.h"

// #ifdef WIN32
// #include "misc_api/windows.h"
// #endif

// #ifndef WIN32
// #include "misc_api/posix.h"
// #endif

// #include "misc_api/misc_api_shared.h"

// #endif // DLIB_MISC_APi_



// Parsed from <mlp.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_MLp_
// #define DLIB_MLp_

// #include "mlp/mlp_kernel_1.h"
// #include "mlp/mlp_kernel_c.h"

    @Namespace("dlib") public static class mlp extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public mlp(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a           

    }


// #endif // DLIB_MLp_



// Parsed from <noncopyable.h>

//  (C) Copyright Beman Dawes 1999-2003. Distributed under the Boost
//  Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//  Contributed by Dave Abrahams
//  See http://www.boost.org/libs/utility for documentation.

// #ifndef DLIB_BOOST_NONCOPYABLE_HPP_INCLUDED
// #define DLIB_BOOST_NONCOPYABLE_HPP_INCLUDED
    @Namespace("dlib") public static class noncopyable extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public noncopyable(Pointer p) { super(p); }
    

    }


// #endif  // DLIB_BOOST_NONCOPYABLE_HPP_INCLUDED



// Parsed from <numeric_constants.h>

//Copyright (C) 2013 Steve Taylor (steve98654@gmail.com), Davis E. King
//License: Boost Software License.  See LICENSE.txt for full license.
// #ifndef DLIB_NUMERIC_CONSTANTs_H_
// #define DLIB_NUMERIC_CONSTANTs_H_

    // pi -- Pi
    @Namespace("dlib") @MemberGetter public static native double pi();

    // e  -- Euler's Constant
    @Namespace("dlib") @MemberGetter public static native double e();

    // sqrt_2 -- The square root of 2
    @Namespace("dlib") @MemberGetter public static native double sqrt_2();

    // sqrt_3 -- The square root of 3
    @Namespace("dlib") @MemberGetter public static native double sqrt_3();

    // log10_2 -- The logarithm base 10 of two
    @Namespace("dlib") @MemberGetter public static native double log10_2();

    // light_spd -- The speed of light in vacuum in meters per second
    @Namespace("dlib") @MemberGetter public static native double light_spd();

    // newton_G  -- Newton's gravitational constant (in metric units of m^3/(kg*s^2))
    @Namespace("dlib") @MemberGetter public static native double newton_G();

    // planck_cst -- Planck's constant (in units of Joules * seconds) 
    @Namespace("dlib") @MemberGetter public static native double planck_cst();

    // golden_ratio -- The Golden Ratio
    @Namespace("dlib") @MemberGetter public static native double golden_ratio();

    // euler_gamma -- The Euler Mascheroni Constant 
    @Namespace("dlib") @MemberGetter public static native double euler_gamma();

    // catalan -- Catalan's Constant
    @Namespace("dlib") @MemberGetter public static native double catalan(); 

    // glaisher -- Glaisher Kinkelin constant
    @Namespace("dlib") @MemberGetter public static native double glaisher();

    // khinchin -- Khinchin's constant
    @Namespace("dlib") @MemberGetter public static native double khinchin();

    // apery -- Apery's constant
    @Namespace("dlib") @MemberGetter public static native double apery();


// #endif //DLIB_NUMERIC_CONSTANTs_H_



// Parsed from <numerical_integration.h>

// Copyright (C) 2013 Steve Taylor (steve98654@gmail.com)
// License: Boost Software License  See LICENSE.txt for the full license.
// #ifndef DLIB_INTEGRATE_FUNCTION_ADAPT_SIMPSON_HEADER
// #define DLIB_INTEGRATE_FUNCTION_ADAPT_SIMPSON_HEADER

// #include "numerical_integration/integrate_function_adapt_simpson.h"

// #endif // DLIB_INTEGRATE_FUNCTION_ADAPT_SIMPSON_HEADER


// Parsed from <opencv.h>

// Copyright (C) 2009  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_OPEnCV_HEADER
// #define DLIB_OPEnCV_HEADER

// #include "opencv/cv_image.h"
// #include "opencv/to_open_cv.h"

// #endif // DLIB_OPEnCV_HEADER






// Parsed from <optimization.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_OPTIMIZATIOn_HEADER
// #define DLIB_OPTIMIZATIOn_HEADER

// #include "optimization/optimization.h"
// #include "optimization/optimization_bobyqa.h"
// #include "optimization/optimization_solve_qp_using_smo.h"
// #include "optimization/optimization_solve_qp2_using_smo.h"
// #include "optimization/optimization_solve_qp3_using_smo.h"
// #include "optimization/optimization_oca.h"
// #include "optimization/optimization_trust_region.h"
// #include "optimization/optimization_least_squares.h"
// #include "optimization/max_cost_assignment.h"
// #include "optimization/max_sum_submatrix.h"
// #include "optimization/find_max_factor_graph_nmplp.h"
// #include "optimization/find_max_factor_graph_viterbi.h"
// #include "optimization/find_max_parse_cky.h"

// #endif // DLIB_OPTIMIZATIOn_HEADER





// Parsed from <pipe.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_PIPe_
// #define DLIB_PIPe_ 

// #include "pipe/pipe_kernel_1.h"


// #endif // DLIB_PIPe_



// Parsed from <pixel.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_PIXEl_ 
// #define DLIB_PIXEl_

// #include <iostream>
// #include "serialize.h"
// #include <cmath>
// #include "algs.h"
// #include "uintn.h"
// #include <limits>
// #include <complex>
// #include "enable_if.h"

// ----------------------------------------------------------------------------------------

    /**
        This file contains definitions of pixel objects and related classes and
        functionality.
    !*/

// ----------------------------------------------------------------------------------------
    /**
        WHAT THIS OBJECT REPRESENTS
            As the name implies, this is a traits class for pixel types.
            It defines the properties of a pixel.
        <p>
        This traits class will define the following public static members:
            - bool grayscale
            - bool rgb
            - bool rgb_alpha
            - bool hsi
            - bool lab
            <p>
            - bool has_alpha
            <p>
            - long num 
            <p>
            - basic_pixel_type
            - basic_pixel_type min()
            - basic_pixel_type max()
            - is_unsigned
        <p>
        The above public constants are subject to the following constraints:
            - only one of grayscale, rgb, rgb_alpha, hsi or lab is true
            - if (rgb == true) then
                - The type T will be a struct with 3 public members of type 
                  unsigned char named "red" "green" and "blue".  
                - This type of pixel represents the RGB color space.
                - num == 3
                - has_alpha == false
                - basic_pixel_type == unsigned char
                - min() == 0 
                - max() == 255
                - is_unsigned == true
            - if (rgb_alpha == true) then
                - The type T will be a struct with 4 public members of type 
                  unsigned char named "red" "green" "blue" and "alpha".  
                - This type of pixel represents the RGB color space with
                  an alpha channel where an alpha of 0 represents a pixel
                  that is totally transparent and 255 represents a pixel 
                  with maximum opacity.
                - num == 4
                - has_alpha == true 
                - basic_pixel_type == unsigned char
                - min() == 0 
                - max() == 255
                - is_unsigned == true
            - else if (hsi == true) then
                - The type T will be a struct with 3 public members of type
                  unsigned char named "h" "s" and "i".  
                - This type of pixel represents the HSI color space.
                - num == 3
                - has_alpha == false 
                - basic_pixel_type == unsigned char
                - min() == 0 
                - max() == 255
                - is_unsigned == true
             - else if (lab == true) then
                - The type T will be a struct with 3 public members of type
                  unsigned char named "l" "a" and "b".
                - This type of pixel represents the Lab color space.
                - num == 3
                - has_alpha == false
                - basic_pixel_type == unsigned char
                - min() == 0
                - max() == 255
                - is_unsigned == true 
            - else
                - grayscale == true
                - This type of pixel represents a grayscale color space.  T 
                  will be some kind of basic scalar type such as unsigned int.
                - num == 1
                - has_alpha == false 
                - basic_pixel_type == T 
                - min() == the minimum obtainable value of objects of type T 
                - max() == the maximum obtainable value of objects of type T 
                - is_unsigned is true if min() == 0 and false otherwise
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") @NoOffset public static class rgb_pixel extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public rgb_pixel(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public rgb_pixel(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public rgb_pixel position(long position) {
            return (rgb_pixel)super.position(position);
        }
    
        /**
            WHAT THIS OBJECT REPRESENTS
                This is a simple struct that represents an RGB colored graphical pixel.
        !*/

        public rgb_pixel(
                ) { super((Pointer)null); allocate(); }
        private native void allocate(
                );

        public rgb_pixel(
                    @Cast("unsigned char") byte red_,
                    @Cast("unsigned char") byte green_,
                    @Cast("unsigned char") byte blue_
                ) { super((Pointer)null); allocate(red_, green_, blue_); }
        private native void allocate(
                    @Cast("unsigned char") byte red_,
                    @Cast("unsigned char") byte green_,
                    @Cast("unsigned char") byte blue_
                );

        public native @Cast("unsigned char") byte red(); public native rgb_pixel red(byte red);
        public native @Cast("unsigned char") byte green(); public native rgb_pixel green(byte green);
        public native @Cast("unsigned char") byte blue(); public native rgb_pixel blue(byte blue);
    }

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") @NoOffset public static class bgr_pixel extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public bgr_pixel(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public bgr_pixel(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public bgr_pixel position(long position) {
            return (bgr_pixel)super.position(position);
        }
    
        /**
            WHAT THIS OBJECT REPRESENTS
                This is a simple struct that represents an BGR colored graphical pixel.
                (the reason it exists in addition to the rgb_pixel is so you can lay
                it down on top of a memory region that organizes its color data in the
                BGR format and still be able to read it)
        !*/

        public bgr_pixel(
                ) { super((Pointer)null); allocate(); }
        private native void allocate(
                );

        public bgr_pixel(
                    @Cast("unsigned char") byte blue_,
                    @Cast("unsigned char") byte green_,
                    @Cast("unsigned char") byte red_
                ) { super((Pointer)null); allocate(blue_, green_, red_); }
        private native void allocate(
                    @Cast("unsigned char") byte blue_,
                    @Cast("unsigned char") byte green_,
                    @Cast("unsigned char") byte red_
                );

        public native @Cast("unsigned char") byte blue(); public native bgr_pixel blue(byte blue);
        public native @Cast("unsigned char") byte green(); public native bgr_pixel green(byte green);
        public native @Cast("unsigned char") byte red(); public native bgr_pixel red(byte red);
    }

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") @NoOffset public static class rgb_alpha_pixel extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public rgb_alpha_pixel(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public rgb_alpha_pixel(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public rgb_alpha_pixel position(long position) {
            return (rgb_alpha_pixel)super.position(position);
        }
    
        /**
            WHAT THIS OBJECT REPRESENTS
                This is a simple struct that represents an RGB colored graphical pixel
                with an alpha channel.
        !*/

        public rgb_alpha_pixel(
                ) { super((Pointer)null); allocate(); }
        private native void allocate(
                );

        public rgb_alpha_pixel(
                    @Cast("unsigned char") byte red_,
                    @Cast("unsigned char") byte green_,
                    @Cast("unsigned char") byte blue_,
                    @Cast("unsigned char") byte alpha_
                ) { super((Pointer)null); allocate(red_, green_, blue_, alpha_); }
        private native void allocate(
                    @Cast("unsigned char") byte red_,
                    @Cast("unsigned char") byte green_,
                    @Cast("unsigned char") byte blue_,
                    @Cast("unsigned char") byte alpha_
                );

        public native @Cast("unsigned char") byte red(); public native rgb_alpha_pixel red(byte red);
        public native @Cast("unsigned char") byte green(); public native rgb_alpha_pixel green(byte green);
        public native @Cast("unsigned char") byte blue(); public native rgb_alpha_pixel blue(byte blue);
        public native @Cast("unsigned char") byte alpha(); public native rgb_alpha_pixel alpha(byte alpha);
    }

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") @NoOffset public static class hsi_pixel extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public hsi_pixel(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public hsi_pixel(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public hsi_pixel position(long position) {
            return (hsi_pixel)super.position(position);
        }
    
        /**
            WHAT THIS OBJECT REPRESENTS
                This is a simple struct that represents an HSI colored graphical pixel.
        !*/

        public hsi_pixel(
                ) { super((Pointer)null); allocate(); }
        private native void allocate(
                );

        public hsi_pixel(
                    @Cast("unsigned char") byte h_,
                    @Cast("unsigned char") byte s_,
                    @Cast("unsigned char") byte i_
                ) { super((Pointer)null); allocate(h_, s_, i_); }
        private native void allocate(
                    @Cast("unsigned char") byte h_,
                    @Cast("unsigned char") byte s_,
                    @Cast("unsigned char") byte i_
                );

        public native @Cast("unsigned char") byte h(); public native hsi_pixel h(byte h);
        public native @Cast("unsigned char") byte s(); public native hsi_pixel s(byte s);
        public native @Cast("unsigned char") byte i(); public native hsi_pixel i(byte i);
    }
    // ----------------------------------------------------------------------------------------

    @Namespace("dlib") @NoOffset public static class lab_pixel extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public lab_pixel(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public lab_pixel(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public lab_pixel position(long position) {
            return (lab_pixel)super.position(position);
        }
    
        /**
            WHAT THIS OBJECT REPRESENTS
                This is a simple struct that represents an Lab colored graphical pixel.
        !*/

        public lab_pixel(
                ) { super((Pointer)null); allocate(); }
        private native void allocate(
                );

        public lab_pixel(
                        @Cast("unsigned char") byte l_,
                        @Cast("unsigned char") byte a_,
                        @Cast("unsigned char") byte b_
                ) { super((Pointer)null); allocate(l_, a_, b_); }
        private native void allocate(
                        @Cast("unsigned char") byte l_,
                        @Cast("unsigned char") byte a_,
                        @Cast("unsigned char") byte b_
                );

        public native @Cast("unsigned char") byte l(); public native lab_pixel l(byte l);
        public native @Cast("unsigned char") byte a(); public native lab_pixel a(byte a);
        public native @Cast("unsigned char") byte b(); public native lab_pixel b(byte b);
    }

// ----------------------------------------------------------------------------------------
    /**
        requires
            - pixel_traits<P1> must be defined
            - pixel_traits<P2> must be defined
        ensures
            - if (P1 and P2 are the same type of pixel) then
                - simply copies the value of src into dest.  In other words,
                  dest will be identical to src after this function returns.
            - else if (P1 and P2 are not the same type of pixel) then
                - assigns pixel src to pixel dest and does any necessary color space
                  conversions.   
                - When converting from a grayscale color space with more than 255 values the
                  pixel intensity is saturated at pixel_traits<P1>::max() or pixel_traits<P1>::min()
                  as appropriate.
                - if (the dest pixel has an alpha channel and the src pixel doesn't) then
                    - #dest.alpha == 255 
                - else if (the src pixel has an alpha channel but the dest pixel doesn't) then
                    - #dest == the original dest value blended with the src value according
                      to the alpha channel in src.  
                      (i.e.  #dest == src*(alpha/255) + dest*(1-alpha/255))
    !*/

// ----------------------------------------------------------------------------------------
    /**
        requires
            - pixel_traits<P> must be defined
        ensures
            - if (pixel_traits<P>::grayscale == true) then
                - returns src
            - else
                - converts src to grayscale and returns the resulting value.
    !*/

// ----------------------------------------------------------------------------------------
    /**
        requires
            - pixel_traits<P> must be defined
            - pixel_traits<T> must be defined
        ensures
            - This function changes the intensity of the dest pixel. So if the pixel in 
              question is a grayscale pixel then it simply assigns that pixel with the 
              value of get_pixel_intensity(new_intensity).  However, if the pixel is not 
              a grayscale pixel then it converts the pixel to the HSI color space and sets 
              the I channel to the given intensity and then converts this HSI value back to 
              the original pixel's color space.
            - Note that we don't necessarily have #get_pixel_intensity(dest) == get_pixel_intensity(new_intensity) 
              due to vagaries of how converting to and from HSI works out.
            - if (the dest pixel has an alpha channel) then
                - #dest.alpha == dest.alpha
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(
            @Const @ByRef rgb_pixel item, 
            @Cast("std::ostream*") @ByRef Pointer out 
        );   
    /**
        provides serialization support for the rgb_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void deserialize(
            @ByRef rgb_pixel item, 
            @Cast("std::istream*") @ByRef Pointer in
        );   
    /**
        provides deserialization support for the rgb_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(
            @Const @ByRef bgr_pixel item, 
            @Cast("std::ostream*") @ByRef Pointer out 
        );   
    /**
        provides serialization support for the bgr_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void deserialize(
            @ByRef bgr_pixel item, 
            @Cast("std::istream*") @ByRef Pointer in
        );   
    /**
        provides deserialization support for the bgr_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(
            @Const @ByRef rgb_alpha_pixel item, 
            @Cast("std::ostream*") @ByRef Pointer out 
        );   
    /**
        provides serialization support for the rgb_alpha_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void deserialize(
            @ByRef rgb_alpha_pixel item, 
            @Cast("std::istream*") @ByRef Pointer in
        );   
    /**
        provides deserialization support for the rgb_alpha_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(
            @Const @ByRef hsi_pixel item, 
            @Cast("std::ostream*") @ByRef Pointer out 
        );   
    /**
        provides serialization support for the hsi_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(
                @Const @ByRef lab_pixel item,
                @Cast("std::ostream*") @ByRef Pointer out
        );
    /**
        provides serialization support for the lab_pixel struct
    !*/


// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void deserialize(
            @ByRef hsi_pixel item, 
            @Cast("std::istream*") @ByRef Pointer in
        );   
    /**
        provides deserialization support for the hsi_pixel struct
    !*/
// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void deserialize(
                @ByRef lab_pixel item,
                @Cast("std::istream*") @ByRef Pointer in
        );
    /**
        provides deserialization support for the lab_pixel struct
    !*/

// ----------------------------------------------------------------------------------------

    @Name("dlib::pixel_traits<dlib::rgb_pixel>") public static class pixel_traits extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public pixel_traits() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public pixel_traits(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public pixel_traits(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public pixel_traits position(long position) {
            return (pixel_traits)super.position(position);
        }
    
        @MemberGetter public static native @Cast("const bool") boolean rgb();
        public static final boolean rgb = rgb();
        @MemberGetter public static native @Cast("const bool") boolean rgb_alpha();
        public static final boolean rgb_alpha = rgb_alpha();
        @MemberGetter public static native @Cast("const bool") boolean grayscale();
        public static final boolean grayscale = grayscale();
        @MemberGetter public static native @Cast("const bool") boolean hsi();
        public static final boolean hsi = hsi();
        @MemberGetter public static native @Cast("const bool") boolean lab();
        public static final boolean lab = lab();
        /** enum dlib::pixel_traits<dlib::rgb_pixel>:: */
        public static final int num = 3;
        public static native @Cast("dlib::pixel_traits<dlib::rgb_pixel>::basic_pixel_type") byte min();
        public static native @Cast("dlib::pixel_traits<dlib::rgb_pixel>::basic_pixel_type") byte max();
        @MemberGetter public static native @Cast("const bool") boolean is_unsigned();
        public static final boolean is_unsigned = is_unsigned();
        @MemberGetter public static native @Cast("const bool") boolean has_alpha();
        public static final boolean has_alpha = has_alpha();
    }

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

    // These are here mainly so you can easily copy images into complex arrays.  This is
    // useful when you want to do a FFT on an image or some similar operation.

// ----------------------------------------------------------------------------------------

    // The following is a bunch of conversion stuff for the assign_pixel function.

    // -----------------------------
        // all the same kind 

    // -----------------------------

        @Namespace("dlib::assign_pixel_helpers") public static native float make_unsigned(float val);
        @Namespace("dlib::assign_pixel_helpers") public static native double make_unsigned(double val);

    // -----------------------------
        /**
            ensures
                - returns true if p is >= min value of T
        !*/
    // -----------------------------

    // -----------------------------
    // -----------------------------
    // -----------------------------

    // -----------------------------
        // dest is a grayscale


    // -----------------------------

        @Namespace("dlib::assign_pixel_helpers") public static class HSL extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public HSL() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public HSL(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public HSL(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public HSL position(long position) {
                return (HSL)super.position(position);
            }
        
            public native double h(); public native HSL h(double h);
            public native double s(); public native HSL s(double s);
            public native double l(); public native HSL l(double l);
        }

        @Namespace("dlib::assign_pixel_helpers") public static class COLOUR extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public COLOUR() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public COLOUR(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public COLOUR(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public COLOUR position(long position) {
                return (COLOUR)super.position(position);
            }
        
            public native double r(); public native COLOUR r(double r);
            public native double g(); public native COLOUR g(double g);
            public native double b(); public native COLOUR b(double b);
        }

        /*
            I found this excellent bit of code for dealing with HSL spaces at 
            http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/
        */
        /*
            Calculate HSL from RGB
            Hue is in degrees
            Lightness is between 0 and 1
            Saturation is between 0 and 1
        */
        @Namespace("dlib::assign_pixel_helpers") public static native @ByVal HSL RGB2HSL(@ByVal COLOUR c1);

        /*
            Calculate RGB from HSL, reverse of RGB2HSL()
            Hue is in degrees
            Lightness is between 0 and 1
            Saturation is between 0 and 1
        */
        @Namespace("dlib::assign_pixel_helpers") public static native @ByVal COLOUR HSL2RGB(@ByVal HSL c1);

        // -----------------------------

        @Namespace("dlib::assign_pixel_helpers") public static class Lab extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public Lab() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Lab(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Lab(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public Lab position(long position) {
                return (Lab)super.position(position);
            }
        
            public native double l(); public native Lab l(double l);
            public native double a(); public native Lab a(double a);
            public native double b(); public native Lab b(double b);
        }
        /*
            Calculate Lab from RGB
            L is between 0 and 100
            a is between -128 and 127
            b is between -128 and 127
            RGB is between 0.0 and 1.0
        */
        @Namespace("dlib::assign_pixel_helpers") public static native @ByVal Lab RGB2Lab(@ByVal COLOUR c1);

        /*
            Calculate RGB from Lab, reverse of RGB2LAb()
            L is between 0 and 100
            a is between -128 and 127
            b is between -128 and 127
            RGB is between 0.0 and 1.0
        */
        @Namespace("dlib::assign_pixel_helpers") public static native @ByVal COLOUR Lab2RGB(@ByVal Lab c1);


    // -----------------------------
        // dest is a color rgb_pixel


    // -----------------------------
    // dest is a color rgb_alpha_pixel
    // -----------------------------
        // dest is an hsi pixel

    // -----------------------------
        // dest is an lab pixel
    

    // -----------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------



// #endif // DLIB_PIXEl_ 



// Parsed from <platform.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_PLATFORm_
// #define DLIB_PLATFORm_


/**
    This file ensures that:
        - if (we are compiling under a posix platform) then
            - POSIX will be defined
            - if (this is also Mac OS X) then
                - MACOSX will be defined
            - if (this is also HP-UX) then
                - HPUX will be defined
        - if (we are compiling under an MS Windows platform) then
            - WIN32 will be defined
!*/


/*
    A good reference for this sort of information is
    http://predef.sourceforge.net/
*/

// Define WIN32 if this is MS Windows
// #ifndef WIN32
//     #if defined( _MSC_VER) || defined(__BORLANDC__) || defined(_WIN32) || defined(__WIN32__) || defined(__TOS_WIN__)
//     #define WIN32 
//     #endif 
// #endif

// #ifndef WIN32
    // since this is the only other platform the library currently supports
    // just assume it is POSIX if it isn't WIN32
//     #ifndef POSIX
//         #define POSIX
//     #endif
 
//     #ifndef HPUX
//        #if defined(__hpux ) || defined(hpux) || defined (_hpux)
//        #define HPUX
//        #endif	
//     #endif

//     #ifndef MACOSX
//         #ifdef __MACOSX__
//         #define MACOSX
//         #endif 
//         #ifdef __APPLE__
//         #define MACOSX
//         #endif
//     #endif

// #endif




// #endif // DLIB_PLATFORm_



// Parsed from <python.h>

// Copyright (C) 2013  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_PYTHoN_TOP_
// #define DLIB_PYTHoN_TOP_ 

// #include "python/boost_python_utils.h"
// #include "python/pyassert.h"
// #include "python/serialize_pickle.h"
// #include "python/numpy.h"
// #include "python/numpy_image.h"

// #endif // DLIB_PYTHoN_TOP_




// Parsed from <quantum_computing.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_QUANTUM_COMPUTINg_H_
// #define DLIB_QUANTUM_COMPUTINg_H_ 

// #include "quantum_computing/quantum_computing.h"

// #endif // DLIB_QUANTUM_COMPUTINg_H_ 






// Parsed from <queue.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_QUEUe_
// #define DLIB_QUEUe_

// #include "queue/queue_kernel_1.h"
// #include "queue/queue_kernel_2.h"
// #include "queue/queue_kernel_c.h"

// #include "queue/queue_sort_1.h"


// #include "algs.h"


// #endif // DLIB_QUEUe_



// Parsed from <rand.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_RANd_
// #define DLIB_RANd_

// #include "rand/rand_kernel_1.h"

// #endif // DLIB_RANd_



// Parsed from <ref.h>

// Copyright (C) 2010  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_REFERENCE_WRAPpER_H_
// #define DLIB_REFERENCE_WRAPpER_H_

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
    /**
        ensures
            - returns a reference_wrapper that contains a reference to obj.
    !*/

// ----------------------------------------------------------------------------------------
    /**
        ensures
            - returns the given reference_wrapper object without modification
    !*/

// ----------------------------------------------------------------------------------------
    /**
        ensures
            - returns a reference_wrapper that contains a constant reference to obj.
    !*/

// ----------------------------------------------------------------------------------------
    /**
        ensures
            - converts the given reference_wrapper into a reference_wrapper that contains a
              constant reference.
    !*/

// ----------------------------------------------------------------------------------------



// #endif // DLIB_REFERENCE_WRAPpER_H_



// Parsed from <reference_counter.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_REFERENCE_COUNTEr_
// #define DLIB_REFERENCE_COUNTEr_

// #include "reference_counter/reference_counter_kernel_1.h"
// #include "algs.h"


// #endif // DLIB_REFERENCE_COUNTEr_



// Parsed from <revision.h>

// #ifndef DLIB_REVISION_H
public static final int DLIB_MAJOR_VERSION =  19;
public static final int DLIB_MINOR_VERSION =  1;
public static final int DLIB_PATCH_VERSION =  0;
// #endif



// Parsed from <sequence.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SEQUENCe_
// #define DLIB_SEQUENCe_

// #include "sequence/sequence_kernel_1.h"
// #include "sequence/sequence_kernel_2.h"
// #include "sequence/sequence_kernel_c.h"

// #include "sequence/sequence_compare_1.h"
// #include "sequence/sequence_sort_1.h"
// #include "sequence/sequence_sort_2.h"
// #include "algs.h"


// #endif // DLIB_SEQUENCe_



// Parsed from <serialize.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SERIALIZe_
// #define DLIB_SERIALIZe_

/**
    There are two global functions in the dlib namespace that provide serialization and
    deserialization support.  Their signatures and specifications are as follows:
        
        void serialize (
            const serializable_type& item,
            std::ostream& out
        );
        /!*
            ensures
                - writes the state of item to the output stream out
                - if (serializable_type implements the enumerable interface) then
                    - item.at_start() == true
            throws                    
                - serialization_error
                    This exception is thrown if there is some problem which prevents
                    us from successfully writing item to the output stream.
                - any other exception
        *!/
        <p>
        void deserialize (
            serializable_type& item,
            std::istream& in
        );
        /!*
            ensures
                - #item == a deserialized copy of the serializable_type that was
                  in the input stream in.
                - Reads all the bytes associated with the serialized serializable_type
                  contained inside the input stream and no more.  This means you
                  can serialize multiple objects to an output stream and then read
                  them all back in, one after another, using deserialize().
                - if (serializable_type implements the enumerable interface) then
                    - item.at_start() == true
            throws                    
                - serialization_error
                    This exception is thrown if there is some problem which prevents
                    us from successfully deserializing item from the input stream.
                    If this exception is thrown then item will have an initial value 
                    for its type.
                - any other exception
        *!/
    <p>
    For convenience, you can also serialize to a file using this syntax:
        serialize("your_file.dat") << some_object << another_object;
    <p>
    That overwrites the contents of your_file.dat with the serialized data from some_object
    and another_object.  Then to recall the objects from the file you can do:
        deserialize("your_file.dat") >> some_object >> another_object;
    <p>
    Finally, you can chain as many objects together using the << and >> operators as you
    like.
    <p>
    <p>
    This file provides serialization support to the following object types:
        - The C++ base types (NOT including pointer types)
        - std::string
        - std::wstring
        - std::vector
        - std::deque
        - std::map
        - std::set
        - std::pair
        - std::complex
        - dlib::uint64
        - dlib::int64
        - float_details
        - enumerable<T> where T is a serializable type
        - map_pair<D,R> where D and R are both serializable types.
        - C style arrays of serializable types
        - Google protocol buffer objects.
    <p>
    This file provides deserialization support to the following object types:
        - The C++ base types (NOT including pointer types)
        - std::string
        - std::wstring
        - std::vector
        - std::deque
        - std::map
        - std::set
        - std::pair
        - std::complex
        - dlib::uint64
        - dlib::int64
        - float_details
        - C style arrays of serializable types
        - Google protocol buffer objects.
    <p>
    Support for deserialization of objects which implement the enumerable or
    map_pair interfaces is the responsibility of those objects.  
    
    Note that you can deserialize an integer value to any integral type (except for a 
    char type) if its value will fit into the target integer type.  I.e.  the types 
    short, int, long, unsigned short, unsigned int, unsigned long, and dlib::uint64 
    can all receive serialized data from each other so long as the actual serizlied 
    value fits within the receiving integral type's range.
    <p>
    Also note that for any container to be serializable the type of object it contains 
    must be serializable.
    <p>
    FILE STREAMS
        If you are serializing to and from file streams it is important to 
        remember to set the file streams to binary mode using the std::ios::binary
        flag.  
    <p>
    <p>
    INTEGRAL SERIALIZATION FORMAT
        All C++ integral types (except the char types) are serialized to the following
        format:
        The first byte is a control byte.  It tells you if the serialized number is 
        positive or negative and also tells you how many of the following bytes are 
        part of the number.  The absolute value of the number is stored in little 
        endian byte order and follows the control byte.
        <p>
        The control byte:  
            The high order bit of the control byte is a flag that tells you if the
            encoded number is negative or not.  It is set to 1 when the number is
            negative and 0 otherwise.
            The 4 low order bits of the control byte represent an unsigned number
            and tells you how many of the following bytes are part of the encoded
            number.
    <p>
    bool SERIALIZATION FORMAT
        A bool value is serialized as the single byte character '1' or '0' in ASCII.
        Where '1' indicates true and '0' indicates false.
    <p>
    FLOATING POINT SERIALIZATION FORMAT
        To serialize a floating point value we convert it into a float_details object and
        then serialize the exponent and mantissa values using dlib's integral serialization
        format.  Therefore, the output is first the exponent and then the mantissa.  Note that
        the mantissa is a signed integer (i.e. there is not a separate sign bit).
!*/


// #include "algs.h"
// #include "assert.h"
// #include <iomanip>
// #include <cstddef>
// #include <iostream>
// #include <fstream>
// #include <string>
// #include <vector>
// #include <deque>
// #include <complex>
// #include <map>
// #include <set>
// #include <limits>
// #include "uintn.h"
// #include "interfaces/enumerable.h"
// #include "interfaces/map_pair.h"
// #include "enable_if.h"
// #include "unicode.h"
// #include "byte_orderer.h"
// #include "float_details.h"
// #include "smart_pointers/shared_ptr.h"

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static class serialization_error extends error {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public serialization_error(Pointer p) { super(p); }
     
        public serialization_error(@StdString BytePointer e) { super((Pointer)null); allocate(e); }
        private native void allocate(@StdString BytePointer e);
        public serialization_error(@StdString String e) { super((Pointer)null); allocate(e); }
        private native void allocate(@StdString String e);
    }

// ----------------------------------------------------------------------------------------

    // ------------------------------------------------------------------------------------

    // ------------------------------------------------------------------------------------

    // ------------------------------------------------------------------------------------

    

// ----------------------------------------------------------------------------------------

//     #define USE_DEFAULT_INT_SERIALIZATION_FOR(T)
//         inline void serialize (const T& item, std::ostream& out)
//         { if (ser_helper::pack_int(item,out)) throw serialization_error("Error serializing object of type " + std::string(#T)); }
//         inline void deserialize (T& item, std::istream& in)
//         { if (ser_helper::unpack_int(item,in)) throw serialization_error("Error deserializing object of type " + std::string(#T)); }

//     #define USE_DEFAULT_BYTE_SERIALIZATION_FOR(T)
//         inline void serialize (const T& item,std::ostream& out)
//         { if (pack_byte(item,out)) throw serialization_error("Error serializing object of type " + std::string(#T)); }
//         inline void deserialize (T& item, std::istream& in)
//         { if (unpack_byte(item,in)) throw serialization_error("Error deserializing object of type " + std::string(#T)); }   

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(short item, @Cast("std::ostream*") @ByRef Pointer out);
        @Namespace("dlib") public static native void deserialize(@ByRef ShortPointer item, @Cast("std::istream*") @ByRef Pointer in);
        @Namespace("dlib") public static native void deserialize(@ByRef ShortBuffer item, @Cast("std::istream*") @ByRef Pointer in);
        @Namespace("dlib") public static native void deserialize(@ByRef short[] item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void serialize(int item, @Cast("std::ostream*") @ByRef Pointer out);
        @Namespace("dlib") public static native void deserialize(@ByRef IntPointer item, @Cast("std::istream*") @ByRef Pointer in);
        @Namespace("dlib") public static native void deserialize(@ByRef IntBuffer item, @Cast("std::istream*") @ByRef Pointer in);
        @Namespace("dlib") public static native void deserialize(@ByRef int[] item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void serialize(long item, @Cast("std::ostream*") @ByRef Pointer out);
        @Namespace("dlib") public static native void deserialize(@ByRef CLongPointer item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void serialize(@Const @ByRef uint64 item, @Cast("std::ostream*") @ByRef Pointer out);
        @Namespace("dlib") public static native void deserialize(@ByRef uint64 item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void serialize(@Const @ByRef int64 item, @Cast("std::ostream*") @ByRef Pointer out);
        @Namespace("dlib") public static native void deserialize(@ByRef int64 item, @Cast("std::istream*") @ByRef Pointer in);

    @Namespace("dlib") public static native void serialize(@Cast("const char") byte item,@Cast("std::ostream*") @ByRef Pointer out);
        @Namespace("dlib") public static native void deserialize(@Cast("char*") @ByRef BytePointer item, @Cast("std::istream*") @ByRef Pointer in);
        @Namespace("dlib") public static native void deserialize(@Cast("char*") @ByRef ByteBuffer item, @Cast("std::istream*") @ByRef Pointer in);
        @Namespace("dlib") public static native void deserialize(@Cast("char*") @ByRef byte[] item, @Cast("std::istream*") @ByRef Pointer in);

    // Don't define serialization for wchar_t when using visual studio and
    // _NATIVE_WCHAR_T_DEFINED isn't defined since if it isn't they improperly set
    // wchar_t to be a typedef rather than its own type as required by the C++ 
    // standard.
// #if !defined(_MSC_VER) || _NATIVE_WCHAR_T_DEFINED
    @Namespace("dlib") public static native void serialize(@Cast("const wchar_t") char item, @Cast("std::ostream*") @ByRef Pointer out);
        @Namespace("dlib") public static native void deserialize(@Cast("wchar_t*") @ByRef CharPointer item, @Cast("std::istream*") @ByRef Pointer in);
// #endif

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(
            @Const @ByRef float_details item,
            @Cast("std::ostream*") @ByRef Pointer out
        );

    @Namespace("dlib") public static native void deserialize(
            @ByRef float_details item,
            @Cast("std::istream*") @ByRef Pointer in 
        );

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize( float item, @Cast("std::ostream*") @ByRef Pointer out);

    @Namespace("dlib") public static native void deserialize(@ByRef FloatPointer item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void deserialize(@ByRef FloatBuffer item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void deserialize(@ByRef float[] item, @Cast("std::istream*") @ByRef Pointer in);

    @Namespace("dlib") public static native void serialize( double item, @Cast("std::ostream*") @ByRef Pointer out);

    @Namespace("dlib") public static native void deserialize(@ByRef DoublePointer item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void deserialize(@ByRef DoubleBuffer item, @Cast("std::istream*") @ByRef Pointer in);
    @Namespace("dlib") public static native void deserialize(@ByRef double[] item, @Cast("std::istream*") @ByRef Pointer in);

    @Namespace("dlib") public static native void deserialize( @Cast("long double*") @ByRef Pointer item, @Cast("std::istream*") @ByRef Pointer in);

// ----------------------------------------------------------------------------------------
// prototypes

    @Namespace("dlib") public static native void serialize(
            @StdString BytePointer item,
            @Cast("std::ostream*") @ByRef Pointer out
        );
    @Namespace("dlib") public static native void serialize(
            @StdString String item,
            @Cast("std::ostream*") @ByRef Pointer out
        );

    @Namespace("dlib") public static native void deserialize(
            @StdString String item,
            @Cast("std::istream*") @ByRef Pointer in
        );

    @Namespace("dlib") public static native void serialize(
            @Const @ByRef wstring item,
            @Cast("std::ostream*") @ByRef Pointer out
        );

    @Namespace("dlib") public static native void deserialize(
            @ByRef wstring item,
            @Cast("std::istream*") @ByRef Pointer in
        );

    @Namespace("dlib") public static native void serialize(
            @Const @ByRef ustring item,
            @Cast("std::ostream*") @ByRef Pointer out
        );

    @Namespace("dlib") public static native void deserialize(
            @ByRef ustring item,
            @Cast("std::istream*") @ByRef Pointer in
        );

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

    @Namespace("dlib") public static native void serialize(
            @Cast("bool") boolean item,
            @Cast("std::ostream*") @ByRef Pointer out
        );

    @Namespace("dlib") public static native void deserialize(
            @Cast("bool*") @ByRef BoolPointer item,
            @Cast("std::istream*") @ByRef Pointer in
        );
    @Namespace("dlib") public static native void deserialize(
            @Cast("bool*") @ByRef boolean[] item,
            @Cast("std::istream*") @ByRef Pointer in
        );

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

    @Namespace("dlib") @NoOffset public static class proxy_serialize extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public proxy_serialize(Pointer p) { super(p); }
    
        public proxy_serialize(
                    @StdString BytePointer filename
                ) { super((Pointer)null); allocate(filename); }
        private native void allocate(
                    @StdString BytePointer filename
                );
        public proxy_serialize(
                    @StdString String filename
                ) { super((Pointer)null); allocate(filename); }
        private native void allocate(
                    @StdString String filename
                );
    }

    @Namespace("dlib") @NoOffset public static class proxy_deserialize extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public proxy_deserialize(Pointer p) { super(p); }
    
        public proxy_deserialize(
                    @StdString BytePointer filename
                ) { super((Pointer)null); allocate(filename); }
        private native void allocate(
                    @StdString BytePointer filename
                );
        public proxy_deserialize(
                    @StdString String filename
                ) { super((Pointer)null); allocate(filename); }
        private native void allocate(
                    @StdString String filename
                );
    }

    @Namespace("dlib") public static native @ByVal proxy_serialize serialize(@StdString BytePointer filename);
    @Namespace("dlib") public static native @ByVal proxy_serialize serialize(@StdString String filename);
    @Namespace("dlib") public static native @ByVal proxy_deserialize deserialize(@StdString BytePointer filename);
    @Namespace("dlib") public static native @ByVal proxy_deserialize deserialize(@StdString String filename);

// ----------------------------------------------------------------------------------------



// forward declare the MessageLite object so we can reference it below.
        @Namespace("google::protobuf") @Opaque public static class MessageLite extends Pointer {
            /** Empty constructor. Calls {@code super((Pointer)null)}. */
            public MessageLite() { super((Pointer)null); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public MessageLite(Pointer p) { super(p); }
        }
    


    /**A is_protocol_buffer
        This is a template that tells you if a type is a Google protocol buffer object.  
    !*/

// ----------------------------------------------------------------------------------------



// #endif // DLIB_SERIALIZe_



// Parsed from <server.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SERVEr_
// #define DLIB_SERVEr_

// #include "server/server_kernel.h"
// #include "server/server_iostream.h"
// #include "server/server_http.h"


// #endif // DLIB_SERVEr_



// Parsed from <set.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SEt_
// #define DLIB_SEt_

// #include "set/set_kernel_1.h"
// #include "set/set_kernel_c.h"



// #include "binary_search_tree.h"

// #include "set/set_compare_1.h"

// #include "algs.h"
// #include <functional>


// #endif // DLIB_SEt_



// Parsed from <set_utils.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SET_UTILs_H_
// #define DLIB_SET_UTILs_H_ 

// #include "set_utils/set_utils.h"

// #endif // DLIB_SET_UTILs_H_ 





// Parsed from <simd.h>

// Copyright (C) 2013  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SIMd_Hh_
// #define DLIB_SIMd_Hh_

// #include "simd/simd4f.h"
// #include "simd/simd4i.h"
// #include "simd/simd8f.h"
// #include "simd/simd8i.h"

// #endif // DLIB_SIMd_Hh_



// Parsed from <sliding_buffer.h>

// Copyright (C) 2004  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SLIDING_BUFFEr_
// #define DLIB_SLIDING_BUFFEr_


// #include "sliding_buffer/sliding_buffer_kernel_1.h"
// #include "sliding_buffer/sliding_buffer_kernel_c.h"
// #include "sliding_buffer/circular_buffer.h"


// #endif // DLIB_SLIDING_BUFFEr_



// Parsed from <smart_pointers.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SMART_POINTERs_H_
// #define DLIB_SMART_POINTERs_H_ 

// #include "smart_pointers/scoped_ptr.h"
// #include "smart_pointers/shared_ptr.h"
// #include "smart_pointers/weak_ptr.h"

// #endif // DLIB_SMART_POINTERs_H_ 




// Parsed from <smart_pointers_thread_safe.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SMART_POINTERs_THREAD_SAFE_H_
// #define DLIB_SMART_POINTERs_THREAD_SAFE_H_ 

// #include "smart_pointers/shared_ptr_thread_safe.h"

// #endif // DLIB_SMART_POINTERs_THREAD_SAFE_H_ 





// Parsed from <sockets.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SOCKETs_
// #define DLIB_SOCKETs_

// #include "platform.h"


// #ifdef WIN32
// #endif

// #ifndef WIN32
// #include "sockets/posix.h"
// #endif

// #include "sockets/sockets_extensions.h"

// #endif // DLIB_SOCKETs_



// Parsed from <sockstreambuf.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SOCKSTREAMBUf_H_h_
// #define DLIB_SOCKSTREAMBUf_H_h_

// #include "sockstreambuf/sockstreambuf.h"
// #include "sockstreambuf/sockstreambuf_unbuffered.h"


// #endif // DLIB_SOCKSTREAMBUf_H_h_



// Parsed from <sort.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SORt_
// #define DLIB_SORt_

// #include "algs.h"
// #include <functional>

// ----------------------------------------------------------------------------------------
    /**
        requires
            - T implements operator[]                                 
            - the items in array must be comparable by comp where comp is a function
              object with the same syntax as std::less<>
            - the items in array must be swappable by a global swap()   
            - left and right are within the bounds of array
              i.e. array[left] and array[right] are valid elements
            - left <= right
        ensures
            - for all elements in #array between and including left and right the 
              ith element is < the i+1 element
            - sorts using a quick sort algorithm
    !*/ 

// ----------------------------------------------------------------------------------------
    /**
        requires
            - T implements operator[]                                 
            - the items in array must be comparable by comp where comp is a function
              object with the same syntax as std::less<>
            - the items in array must be swappable by a global swap()   
            - left and right are within the bounds of array
              i.e. array[left] and array[right] are valid elements
            - left <= right
        ensures
            - for all elements in #array between and including left and right the 
              ith element is < the i+1 element
            - sorts using a heapsort algorithm
    !*/ 

// ----------------------------------------------------------------------------------------
    /**
        requires
            - T implements operator[]                                 
            - the items in array must be comparable by comp where comp is a function
              object with the same syntax as std::less<>
            - the items in array must be swappable by a global swap()   
            - left and right are within the bounds of array
              i.e. array[left] and array[right] are valid elements
            - left <= right
        ensures
            - for all elements in #array between and including left and right the 
              ith element is < the i+1 element
            - sorts using an insertion sort algorithm
    !*/

// ---------------------------------------------------------------------------------------- 
    /**
        requires
            - T implements operator[]                                 
            - the items in array must be comparable by std::less         
            - the items in array must be swappable by a global swap()   
            - left and right are within the bounds of array
              i.e. array[left] and array[right] are valid elements
            - left <= right
        ensures
            - for all elements in #array between and including left and right the 
              ith element is < the i+1 element
            - sorts using a quick sort algorithm
    !*/ 

// ----------------------------------------------------------------------------------------
    /**
        requires
            - T implements operator[]                                 
            - the items in array must be comparable by std::less         
            - the items in array must be swappable by a global swap()   
            - left and right are within the bounds of array
              i.e. array[left] and array[right] are valid elements
            - left <= right
        ensures
            - for all elements in #array between and including left and right the 
              ith element is < the i+1 element
            - sorts using a heapsort algorithm
    !*/ 

// ---------------------------------------------------------------------------------------- 
    /**
        requires
            - T implements operator[]                                 
            - the items in array must be comparable by std::less      
            - the items in array must be swappable by a global swap()   
            - left and right are within the bounds of array
              i.e. array[left] and array[right] are valid elements
            - left <= right
        ensures
            - for all elements in #array between and including left and right the 
              ith element is < the i+1 element
            - sorts using an insertion sort algorithm
    !*/

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
//                            IMPLEMENTATION DETAILS
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
    
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------



// #endif // DLIB_SORt_



// Parsed from <sparse_vector.h>

// Copyright (C) 2012  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SPaRSE_VECTOR_Hh_
// #define DLIB_SPaRSE_VECTOR_Hh_ 

// #include "svm/sparse_vector.h"

// #endif // DLIB_SPaRSE_VECTOR_Hh_ 




// Parsed from <sqlite.h>

// Copyright (C) 2011  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SQLiTE_HEADER
// #define DLIB_SQLiTE_HEADER

// #include "sqlite/sqlite_tools.h"

// #endif // DLIB_SVm_HEADER





// Parsed from <stack.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_STACk_
// #define DLIB_STACk_

// #include "stack/stack_kernel_1.h"
// #include "stack/stack_kernel_c.h"
// #include "algs.h"


// #endif // DLIB_STACk_



// Parsed from <stack_trace.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_STACK_TRACe_
// #define DLIB_STACK_TRACe_

/**
    This file defines 3 things.  Two of them are preprocessor macros that
    enable you to tag functions with the dlib stack trace watcher.  The
    third thing is a function named get_stack_trace() which returns the
    current stack trace in std::string form.
    <p>
    To enable the stack trace you must #define DLIB_ENABLE_STACK_TRACE.
    When this #define isn't set then the 3 things described above
    still exist but they don't do anything.
    <p>
    Also note that when the stack trace is enabled it changes the DLIB_ASSERT
    and DLIB_CASSERT macros so that they print stack traces when 
    an assert fails.
    <p>
    See the following example program for details:
    <p>
    #include <iostream>
    #include <dlib/stack_trace.h>
    <p>
    void funct2()
    {
        // put this macro at the top of each function you would
        // like to appear in stack traces
        DLIB_STACK_TRACE;
        <p>
        // you may print the current stack trace as follows. 
        std::cout << dlib::get_stack_trace() << endl;
    }
    <p>
    void funct()
    {
        // This alternate form of DLIB_STACK_TRACE allows you to specify
        // the string used to name the current function.  The other form
        // will usually output an appropriate function name automatically
        // so this may not be needed.
        DLIB_STACK_TRACE_NAMED("funct");
        funct2();
    }
    <p>
    int main()
    {
        funct();
    }
!*/


// #include <string>
// #include "assert.h"

// only setup the stack trace stuff if the asserts are enabled (which happens in debug mode
// basically).  Also, this stuff doesn't work if you use NO_MAKEFILE
// #if defined(DLIB_ENABLE_STACK_TRACE) 
// #ifdef NO_MAKEFILE 
// #error "You can't use the dlib stack trace stuff and NO_MAKEFILE at the same time"
// #endif
    @Namespace("dlib") public static native @StdString BytePointer get_stack_trace();


// redefine the DLIB_CASSERT macro to include the stack trace
// #undef DLIB_CASSERT
// #define DLIB_CASSERT(_exp,_message)
//     {if ( !(_exp) )
//     {
//         std::ostringstream dlib_o_out;
//         dlib_o_out << "\n\nError occurred at line " << __LINE__ << ".\n";
//         dlib_o_out << "Error occurred in file " << __FILE__ << ".\n";
//         dlib_o_out << "Error occurred in function " << DLIB_FUNCTION_NAME << ".\n\n";
//         dlib_o_out << "Failing expression was " << #_exp << ".\n";
//         dlib_o_out << _message << "\n\n";
//         dlib_o_out << "Stack Trace: \n" << dlib::get_stack_trace() << "\n";
//         dlib_assert_breakpoint();
//         throw dlib::fatal_error(dlib::EBROKEN_ASSERT,dlib_o_out.str());
//     }}

    @Namespace("dlib") public static class stack_tracer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public stack_tracer(Pointer p) { super(p); }
    
        public stack_tracer(
                    @Cast("const char*") BytePointer funct_name,
                    @Cast("const char*") BytePointer file_name,
                    int line_number
                ) { super((Pointer)null); allocate(funct_name, file_name, line_number); }
        private native void allocate(
                    @Cast("const char*") BytePointer funct_name,
                    @Cast("const char*") BytePointer file_name,
                    int line_number
                );
        public stack_tracer(
                    String funct_name,
                    String file_name,
                    int line_number
                ) { super((Pointer)null); allocate(funct_name, file_name, line_number); }
        private native void allocate(
                    String funct_name,
                    String file_name,
                    int line_number
                );

    }


// #define DLIB_STACK_TRACE_NAMED(x) dlib::stack_tracer dlib_stack_tracer_object(x,__FILE__,__LINE__)
public static native @MemberGetter int DLIB_STACK_TRACE();
public static final int DLIB_STACK_TRACE = DLIB_STACK_TRACE();

// #else // don't do anything if ENABLE_ASSERTS isn't defined
// #define DLIB_STACK_TRACE_NAMED(x) 
// #define DLIB_STACK_TRACE


// #endif


// #endif // DLIB_STACK_TRACe_



// Parsed from <static_map.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_STATIC_MAp_
// #define DLIB_STATIC_MAp_

// #include "static_map/static_map_kernel_1.h"
// #include "static_map/static_map_kernel_c.h"

// #include <functional>


// #endif // DLIB_STATIC_MAp_



// Parsed from <static_set.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_STATIC_SEt_
// #define DLIB_STATIC_SEt_

// #include "static_set/static_set_kernel_1.h"
// #include "static_set/static_set_kernel_c.h"
// #include "static_set/static_set_compare_1.h"

// #include <functional>


// #endif // DLIB_STATIC_SEt_



// Parsed from <statistics.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_STATISTICs_H_
// #define DLIB_STATISTICs_H_ 

// #include "statistics/statistics.h"
// #include "statistics/dpca.h"
// #include "statistics/random_subset_selector.h"
// #include "statistics/image_feature_sampling.h"
// #include "statistics/sammon.h"
// #include "statistics/cca.h"
// #include "statistics/average_precision.h"
// #include "statistics/vector_normalizer_frobmetric.h"
// #include "statistics/lda.h"

// #endif // DLIB_STATISTICs_H_ 





// Parsed from <stl_checked.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_STL_CHECKEd_HEADER
// #define DLIB_STL_CHECKEd_HEADER

// #include "stl_checked/std_vector_c.h"

// #endif // DLIB_STL_CHECKEd_HEADER




// Parsed from <string.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_STRINg_TOP_
// #define DLIB_STRINg_TOP_ 

// #include "string/string.h"

// #endif // DLIB_STRINg_TOP_



// Parsed from <svm.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_SVm_HEADER
// #define DLIB_SVm_HEADER

// #include "svm/svm_rank_trainer.h"
// #include "svm/svm.h"
// #include "svm/krls.h"
// #include "svm/rls.h"
// #include "svm/kcentroid.h"
// #include "svm/kcentroid_overloads.h"
// #include "svm/kkmeans.h"
// #include "svm/feature_ranking.h"
// #include "svm/rbf_network.h"
// #include "svm/linearly_independent_subset_finder.h"
// #include "svm/reduced.h"
// #include "svm/rvm.h"
// #include "svm/pegasos.h"
// #include "svm/sparse_kernel.h"
// #include "svm/null_trainer.h"
// #include "svm/roc_trainer.h"
// #include "svm/kernel_matrix.h"
// #include "svm/empirical_kernel_map.h"
// #include "svm/svm_c_linear_trainer.h"
// #include "svm/svm_c_linear_dcd_trainer.h"
// #include "svm/svm_c_ekm_trainer.h"
// #include "svm/simplify_linear_decision_function.h"
// #include "svm/krr_trainer.h"
// #include "svm/sort_basis_vectors.h"
// #include "svm/svm_c_trainer.h"
// #include "svm/svm_one_class_trainer.h"
// #include "svm/svr_trainer.h"

// #include "svm/one_vs_one_decision_function.h"
// #include "svm/multiclass_tools.h"
// #include "svm/cross_validate_multiclass_trainer.h"
// #include "svm/cross_validate_regression_trainer.h"
// #include "svm/cross_validate_object_detection_trainer.h"
// #include "svm/cross_validate_sequence_labeler.h"
// #include "svm/cross_validate_sequence_segmenter.h"
// #include "svm/cross_validate_assignment_trainer.h"

// #include "svm/one_vs_all_decision_function.h"

// #include "svm/structural_svm_problem.h"
// #include "svm/sequence_labeler.h"
// #include "svm/assignment_function.h"
// #include "svm/track_association_function.h"
// #include "svm/active_learning.h"
// #include "svm/svr_linear_trainer.h"
// #include "svm/sequence_segmenter.h"

// #endif // DLIB_SVm_HEADER




// Parsed from <svm_threaded.h>

// Copyright (C) 2008  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_SVm_THREADED_HEADER
// #define DLIB_SVm_THREADED_HEADER

// #include "svm.h"
// #include "svm/svm_threaded.h"
// #include "svm/structural_svm_problem_threaded.h"
// #include "svm/structural_svm_distributed.h"
// #include "svm/structural_svm_object_detection_problem.h"
// #include "svm/structural_object_detection_trainer.h"
// #include "svm/structural_svm_sequence_labeling_problem.h"
// #include "svm/structural_sequence_labeling_trainer.h"

// #include "svm/structural_svm_assignment_problem.h"
// #include "svm/structural_assignment_trainer.h"
// #include "svm/cross_validate_track_association_trainer.h"
// #include "svm/structural_track_association_trainer.h"

// #include "svm/structural_svm_graph_labeling_problem.h"
// #include "svm/structural_graph_labeling_trainer.h"
// #include "svm/cross_validate_graph_labeling_trainer.h"
// #include "svm/svm_multiclass_linear_trainer.h"
// #include "svm/one_vs_one_trainer.h"
// #include "svm/one_vs_all_trainer.h"
// #include "svm/structural_sequence_segmentation_trainer.h"

// #endif // DLIB_SVm_THREADED_HEADER





// Parsed from <sync_extension.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_SYNC_EXTENSIOn_
// #define DLIB_SYNC_EXTENSIOn_

// #include "sync_extension/sync_extension_kernel_1.h"


// #endif // DLIB_SYNC_EXTENSIOn_



// Parsed from <threads.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifdef DLIB_ALL_SOURCE_END
// #include "dlib_basic_cpp_build_tutorial.txt"
// #endif

// #ifndef DLIB_THREADs_
// #define DLIB_THREADs_

// #include "threads/threads_kernel.h"

// #include "threads/auto_mutex_extension.h"
// #include "threads/auto_unlock_extension.h"
// #include "threads/create_new_thread_extension.h"
// #include "threads/multithreaded_object_extension.h"
// #include "threads/rmutex_extension.h"
// #include "threads/rsignaler_extension.h"
// #include "threads/threaded_object_extension.h"
// #include "threads/thread_specific_data_extension.h"
// #include "threads/thread_function_extension.h"
// #include "threads/thread_pool_extension.h"
// #include "threads/read_write_mutex_extension.h"
// #include "threads/parallel_for_extension.h"
// #include "threads/async.h"

// #endif // DLIB_THREADs_



// Parsed from <time_this.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_TIME_THIs_
// #define DLIB_TIME_THIs_


// #include "platform.h"



// #ifndef WIN32

// #include <sys/times.h>
// #include <limits.h>
// #include <unistd.h>
// #include <iostream>
// ----------------------------------------------------------------------------------------

// #define TIME_THIS_TO(_tt_op,_tt_out)
//     {
//         clock_t _tt_start, _tt_end;
//         tms _tt_timesbuf;
//         _tt_start = times(&_tt_timesbuf);
//         _tt_op;
//         _tt_end = times(&_tt_timesbuf);
//         long _tt_ticks = sysconf(_SC_CLK_TCK);
//         if ((double)(_tt_end-_tt_start)/(double)_tt_ticks < 1)
//         {
//             _tt_out << "\ntime: "
//             << (int)(1000*((double)(_tt_end-_tt_start)/(double)_tt_ticks)) << "ms\n";
//         }
//         else
//         {
//             _tt_out << "\ntime: "
//                       << (double)(_tt_end-_tt_start)/(double)_tt_ticks << "sec\n";
//         }
//     }                                                                                       


// #define TIME_THIS(_tt_op)  TIME_THIS_TO(_tt_op,std::cout)

// ----------------------------------------------------------------------------------------


// #endif

// #ifdef WIN32

// #endif

// #endif // DLIB_TIME_THIs_



// Parsed from <timeout.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_TIMEOUt_
// #define DLIB_TIMEOUt_

// #include "timeout/timeout.h"

// #endif // DLIB_TIMEOUt_




// Parsed from <timer.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_TIMEr_
// #define DLIB_TIMEr_

// #include "timer/timer.h"
// #include "timer/timer_heavy.h"

// #endif // DLIB_TIMEr_



// Parsed from <timing.h>

// Copyright (C) 2011  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_TImING_Hh_
// #define DLIB_TImING_Hh_

// #include "misc_api.h"
// #include <cstring>
// #include "string.h"

// #include <iostream>

// ----------------------------------------------------------------------------------------

/**A timing
    <p>
    This set of functions is useful for determining how much time is spent
    executing blocks of code.  Consider the following example:
    <p>
    int main()
    {
        using namespace dlib::timing;
        for (int i = 0; i < 10; ++i)
        {
            // timing block #1
            start(1,"block #1");
            dlib::sleep(500);
            stop(1);
            <p>
            // timing block #2
            start(2,"block #2");
            dlib::sleep(1000);
            stop(2);
        }
        <p>
        print();
    }
    <p>
    This program would output:
        Timing report: 
            block #1: 5.0 seconds
            block #2: 10.0 seconds
    <p>
    So we spent 5 seconds in block #1 and 10 seconds in block #2
    <p>
    <p>
    <p>
    Additionally, note that you can use an RAII style timing block object.  For
    example, if we wanted to find out how much time we spent in a loop a convenient
    way to do this would be as follows:
    <p>
    int main()
    {
        using namespace dlib::timing;
        for (int i = 0; i < 10; ++i)
        {
            block tb(1, "main loop");
            <p>
            dlib::sleep(1500);
        } 
        <p>
        print();
    }
    <p>
    This program would output:
        Timing report: 
            block main loop: 15.0 seconds
<p>
!*/

// ----------------------------------------------------------------------------------------
        @Namespace("dlib::timing") @MemberGetter public static native int TIME_SLOTS();
        @Namespace("dlib::timing") @MemberGetter public static native int NAME_LENGTH();

        @Namespace("dlib::timing") public static native uint64 time_buf();

        @Namespace("dlib::timing") public static native @Cast("char*") BytePointer name_buf(int i, @Cast("const char*") BytePointer name);
        @Namespace("dlib::timing") public static native @Cast("char*") ByteBuffer name_buf(int i, String name);

        @Namespace("dlib::timing") public static native @ByRef timestamper ts();

        @Namespace("dlib::timing") public static native void start(int i );

        @Namespace("dlib::timing") public static native void start(int i, @Cast("const char*") BytePointer name);
        @Namespace("dlib::timing") public static native void start(int i, String name);

        @Namespace("dlib::timing") public static native void stop(int i);

        @Namespace("dlib::timing") public static native void print();

        @Namespace("dlib::timing") public static native void clear();

        @Namespace("dlib::timing") @NoOffset public static class block extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public block(Pointer p) { super(p); }
        
            /**
                WHAT THIS OBJECT REPRESENTS
                    This is an RAII tool for calling start() and stop()
            !*/

            public block(int i) { super((Pointer)null); allocate(i); }
            private native void allocate(int i);
            public block(int i, @Cast("const char*") BytePointer str) { super((Pointer)null); allocate(i, str); }
            private native void allocate(int i, @Cast("const char*") BytePointer str);
            public block(int i, String str) { super((Pointer)null); allocate(i, str); }
            private native void allocate(int i, String str);
            @MemberGetter public native int idx();
        }
    



// #endif // DLIB_TImING_Hh_



// Parsed from <tokenizer.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_TOKENIZEr_
// #define DLIB_TOKENIZEr_

// #include "tokenizer/tokenizer_kernel_1.h"
// #include "tokenizer/tokenizer_kernel_c.h"

    @Namespace("dlib") public static class tokenizer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public tokenizer(Pointer p) { super(p); }
    
        
        //----------- kernels ---------------

        // kernel_1a        
          

    }


// #endif // DLIB_TOKENIZEr_



// Parsed from <tuple.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_TUPLe_TOP_
// #define DLIB_TUPLe_TOP_ 

// #include "tuple/tuple.h"

// #endif // DLIB_TUPLe_TOPh_




// Parsed from <type_safe_union.h>

// Copyright (C) 2009  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_TYPE_SAFE_UNIOn_TOP_
// #define DLIB_TYPE_SAFE_UNIOn_TOP_ 

// #include "type_safe_union/type_safe_union_kernel.h"

// #endif // DLIB_TYPE_SAFE_UNIOn_TOP_





// Parsed from <uintn.h>

// Copyright (C) 2005  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.

// #ifndef DLIB_UINtn_
// #define DLIB_UINtn_

// #include "assert.h"

    /**
        uint64 is a typedef for an unsigned integer that is exactly 64 bits wide.
        uint32 is a typedef for an unsigned integer that is exactly 32 bits wide.
        uint16 is a typedef for an unsigned integer that is exactly 16 bits wide.
        uint8  is a typedef for an unsigned integer that is exactly 8  bits wide.
        <p>
        int64 is a typedef for an integer that is exactly 64 bits wide.
        int32 is a typedef for an integer that is exactly 32 bits wide.
        int16 is a typedef for an integer that is exactly 16 bits wide.
        int8  is a typedef for an integer that is exactly 8  bits wide.
    !*/


// #ifdef __GNUC__
// #elif defined(__BORLANDC__)
// #elif defined(_MSC_VER)
// #else
// #endif


    // make sure these types have the right sizes on this platform
    /**
        ensures
            - sizeof(unsigned_type<T>::type) == sizeof(T)
            - unsigned_type<T>::type is an unsigned integral type
    !*/



// #endif // DLIB_UINtn_



// Parsed from <unicode.h>

// Copyright (C) 2007  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_UNICODe_TOP_
// #define DLIB_UNICODe_TOP_ 

// #include "unicode/unicode.h"

// #endif // DLIB_UNICODe_TOP_



// Parsed from <unordered_pair.h>

// Copyright (C) 2010  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_UNORDERED_PAiR_Hh_
// #define DLIB_UNORDERED_PAiR_Hh_

// #include "serialize.h"

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------



// #endif // DLIB_UNORDERED_PAiR_Hh_



// Parsed from <vectorstream.h>

// Copyright (C) 2012  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_VECTORSTReAMh_
// #define DLIB_VECTORSTReAMh_

// #include "vectorstream/vectorstream.h"
// #include "vectorstream/unserialize.h"


// #endif // DLIB_VECTORSTReAMh_



// Parsed from <windows_magic.h>

// Copyright (C) 2006  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_WINDOWS_MAGIc_ 
// #define DLIB_WINDOWS_MAGIc_ 

// #include "platform.h"

// #ifdef WIN32

// #endif // WIN32

// #endif // DLIB_WINDOWS_MAGIc_



// Parsed from <xml_parser.h>

// Copyright (C) 2003  Davis E. King (davis@dlib.net)
// License: Boost Software License   See LICENSE.txt for the full license.
// #ifndef DLIB_XML_PARSEr_
// #define DLIB_XML_PARSEr_

// #include <string>

// #include "xml_parser/xml_parser_kernel_interfaces.h"
// #include "xml_parser/xml_parser_kernel_1.h"


// #endif // DLIB_XML_PARSEr_



}
